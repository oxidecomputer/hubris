name: build-boards.yml (reusable)
on:
  workflow_call:
    inputs:
      os:
        description: OS to build for
        required: true
        type: string
      filter-directories:
        description: Space-separated list of directories to build
        required: false
        default: .
        type: string
      attest:
        description: Whether to attest the built artifacts.
        required: false
        default: false
        type: boolean
      upload-artifacts:
        description: Whether to upload built boards to the artifacts.
        required: false
        default: false
        type: boolean
      caboose-version:
        description: Version number to insert in the caboose
        required: false
        default: ""
        type: string

# Force permissions to be defined at the job level.
permissions: {}

jobs:
  scheduler:
    name: determine job matrix
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      matrix: ${{ steps.matrix.outputs.matrix }}
    steps:
      - name: Checkout the source code
        uses: actions/checkout@v5

      - name: Calculate the CI matrix
        # The $filter_directories bash variable is intentionally not quoted to allow for multiple
        # filtered paths to be provided in the same job.
        run: build/gha-build-boards-matrix.py ${filter_directories} --write-github-output
        id: matrix
        env:
          filter_directories: ${{ inputs.filter-directories }}

  build:
    needs:
      - scheduler
    name: "${{ matrix.job_name }}"
    runs-on: ${{ inputs.os }}
    permissions:
      contents: read
      id-token: write
      attestations: write

    # We have *a lot* of boards, declaratively defined in the repository through their app.toml
    # files. Rather than duplicating the list of them here (inevitably forgetting to add some), we
    # use a script in the `scheduler` job to dynamically calculate the matrix, and inject it here.
    strategy:
      matrix:
        include: ${{ fromJSON(needs.scheduler.outputs.matrix) }}

    env:
      VCPKGRS_DYNAMIC: 1
    steps:
      - name: Checkout the source code
        uses: actions/checkout@v5

      - name: Install Rust toolchain
        run: |
          rustup show active-toolchain || rustup toolchain install
          rustup show
          rustup component add clippy

      - name: Cache build output
        uses: Swatinem/rust-cache@v2

      - name: Cache vcpkg
        uses: actions/cache@v4
        if: runner.os == 'Windows'
        with:
          path: C:\vcpkg\downloads
          key: ${{ runner.os }}-vcpkg-download-${{ inputs.os }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-vcpkg-download-${{ inputs.os }}-
            ${{ runner.os }}-vcpkg-download-

      - name: cargo xtask dist
        run: |
          # GitHub Actions defaults the environment variable to an empty string when missing.
          if [[ "${HUBRIS_CABOOSE_VERS}" == "" ]]; then
            unset HUBRIS_CABOOSE_VERS
          fi
          cargo xtask dist "${app_toml}"
        shell: bash
        env:
          app_toml: ${{ matrix.app_toml }}
          HUBRIS_CABOOSE_VERS: ${{ inputs.caboose-version }}
          RUST_BACKTRACE: 1

      - name: Fetch Humility
        if: runner.os == 'Linux'
        run: |
          gh release download -R oxidecomputer/humility nightly -p humility -O target/release/humility
          chmod +x target/release/humility
        env:
          # The oxidecomputer/humility repository is public, so *in theory* we don't need a token to
          # download releases from it. In practice we occasionally saw downloading Humility failing
          # with a 429 (too many requests) status code. To avoid that we use the `gh` CLI with the
          # job's GitHub token to download, granting us higher rate limits.
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Test Humility manifest
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update && sudo apt-get install -y libusb-1.0-0-dev libftdi1-dev
          for image in ${images}; do
              target/release/humility -a "target/${name}/dist/${image}/build-${name}-image-${image}.zip" manifest;
          done
        env:
          name: ${{ matrix.app_name }}
          images: ${{ matrix.image }}

      - name: Clippy
        if: runner.os == 'Linux'
        run: |
          cargo xtask clippy ${{ matrix.app_toml }} -- --deny warnings

      - name: Attestation
        uses: actions/attest-build-provenance@v1
        id: attest
        if: inputs.attest
        with:
          subject-path: target/${{ matrix.app_name }}/dist/*/build-${{ matrix.app_name }}-image-*.zip
          show-summary: false

      - name: Prepare artifacts for upload
        id: prepare-upload
        if: inputs.upload-artifacts
        run: |
          path="$(cargo xtask gha-prepare-artifacts $APP_TOML $ATTESTATION)"
          echo "path=$path" >> $GITHUB_OUTPUT
        env:
          APP_TOML: ${{ matrix.app_toml }}
          ATTESTATION: ${{ inputs.attest && steps.attest.outputs.bundle-path || '' }}

      - name: Upload build archive
        uses: actions/upload-artifact@v4
        if: inputs.upload-artifacts
        with:
          name: dist-${{ inputs.os }}-${{ matrix.app_name }}
          path: ${{ steps.prepare-upload.outputs.path }}
