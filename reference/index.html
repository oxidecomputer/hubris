<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.26">
<title>Hubris Reference</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock pre>code{display:block}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge, pre.rouge .w {
  color: #24292f;
  background-color: #f6f8fa;
}
pre.rouge .k, pre.rouge .kd, pre.rouge .kn, pre.rouge .kp, pre.rouge .kr, pre.rouge .kt, pre.rouge .kv {
  color: #cf222e;
}
pre.rouge .gr {
  color: #f6f8fa;
}
pre.rouge .gd {
  color: #82071e;
  background-color: #ffebe9;
}
pre.rouge .nb {
  color: #953800;
}
pre.rouge .nc {
  color: #953800;
}
pre.rouge .no {
  color: #953800;
}
pre.rouge .nn {
  color: #953800;
}
pre.rouge .sr {
  color: #116329;
}
pre.rouge .na {
  color: #116329;
}
pre.rouge .nt {
  color: #116329;
}
pre.rouge .gi {
  color: #116329;
  background-color: #dafbe1;
}
pre.rouge .ges {
  font-weight: bold;
  font-style: italic;
}
pre.rouge .kc {
  color: #0550ae;
}
pre.rouge .l, pre.rouge .ld, pre.rouge .m, pre.rouge .mb, pre.rouge .mf, pre.rouge .mh, pre.rouge .mi, pre.rouge .il, pre.rouge .mo, pre.rouge .mx {
  color: #0550ae;
}
pre.rouge .sb {
  color: #0550ae;
}
pre.rouge .bp {
  color: #0550ae;
}
pre.rouge .ne {
  color: #0550ae;
}
pre.rouge .nl {
  color: #0550ae;
}
pre.rouge .py {
  color: #0550ae;
}
pre.rouge .nv, pre.rouge .vc, pre.rouge .vg, pre.rouge .vi, pre.rouge .vm {
  color: #0550ae;
}
pre.rouge .o, pre.rouge .ow {
  color: #0550ae;
}
pre.rouge .gh {
  color: #0550ae;
  font-weight: bold;
}
pre.rouge .gu {
  color: #0550ae;
  font-weight: bold;
}
pre.rouge .s, pre.rouge .sa, pre.rouge .sc, pre.rouge .dl, pre.rouge .sd, pre.rouge .s2, pre.rouge .se, pre.rouge .sh, pre.rouge .sx, pre.rouge .s1, pre.rouge .ss {
  color: #0a3069;
}
pre.rouge .nd {
  color: #8250df;
}
pre.rouge .nf, pre.rouge .fm {
  color: #8250df;
}
pre.rouge .err {
  color: #f6f8fa;
  background-color: #82071e;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cm, pre.rouge .cp, pre.rouge .cpf, pre.rouge .c1, pre.rouge .cs {
  color: #6e7781;
}
pre.rouge .gl {
  color: #6e7781;
}
pre.rouge .gt {
  color: #6e7781;
}
pre.rouge .ni {
  color: #24292f;
}
pre.rouge .si {
  color: #24292f;
}
pre.rouge .ge {
  color: #24292f;
  font-style: italic;
}
pre.rouge .gs {
  color: #24292f;
  font-weight: bold;
}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Hubris Reference</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">1. Introduction</a>
<ul class="sectlevel2">
<li><a href="#_obligatory_bulleted_list_of_features">1.1. Obligatory bulleted list of features</a></li>
<li><a href="#_architecture">1.2. Architecture</a></li>
<li><a href="#_philosophy">1.3. Philosophy</a>
<ul class="sectlevel3">
<li><a href="#_toward_robustness">1.3.1. Toward robustness</a></li>
<li><a href="#_pragmatism">1.3.2. Pragmatism</a></li>
<li><a href="#_implementation">1.3.3. Implementation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#tasks">2. Tasks</a>
<ul class="sectlevel2">
<li><a href="#_a_brief_note_on_priorities">2.1. A brief note on priorities</a></li>
<li><a href="#_scheduling">2.2. Scheduling</a></li>
<li><a href="#_separate_compilation">2.3. Separate compilation</a></li>
<li><a href="#immortal">2.4. Tasks can&#8217;t be created or destroyed</a></li>
<li><a href="#_failure_and_supervision">2.5. Failure and supervision</a></li>
<li><a href="#_initialization_and_re_initialization">2.6. Initialization and re-initialization</a></li>
</ul>
</li>
<li><a href="#ipc">3. IPC</a>
<ul class="sectlevel2">
<li><a href="#_synchronous_ipc_basics">3.1. Synchronous IPC basics</a>
<ul class="sectlevel3">
<li><a href="#_why_synchronous">3.1.1. Why synchronous?</a></li>
</ul>
</li>
<li><a href="#_sending_messages">3.2. Sending messages</a>
<ul class="sectlevel3">
<li><a href="#response-codes">3.2.1. Response codes and <code>Result</code></a></li>
<li><a href="#_message_size_limits">3.2.2. Message size limits</a></li>
<li><a href="#leases">3.2.3. Lending out memory</a></li>
<li><a href="#_making_this_concrete">3.2.4. Making this concrete</a></li>
</ul>
</li>
<li><a href="#recv-and-reply">3.3. Receiving and handling messages</a>
<ul class="sectlevel3">
<li><a href="#_pipelining_out_of_order_replies_and_reply_failure">3.3.1. Pipelining, out-of-order replies, and reply failure</a></li>
<li><a href="#_handling_error_cases_on_receive">3.3.2. Handling error cases on receive</a></li>
<li><a href="#open-and-closed-recv">3.3.3. Open and closed receive</a></li>
</ul>
</li>
<li><a href="#death">3.4. Death and IPC</a></li>
<li><a href="#notifications">3.5. Notifications: the <em>other</em> IPC mechanism</a>
<ul class="sectlevel3">
<li><a href="#_what_are_they_good_for">3.5.1. What are they good for?</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_interrupts">4. Interrupts</a>
<ul class="sectlevel2">
<li><a href="#_interrupts_vs_exceptions">4.1. Interrupts vs Exceptions</a></li>
<li><a href="#_the_hubris_interrupt_model">4.2. The Hubris interrupt model</a></li>
<li><a href="#interrupts-from-a-tasks-perspective">4.3. Interrupts from a task&#8217;s perspective</a></li>
<li><a href="#_routing_interrupts_to_tasks_in_the_kernel">4.4. Routing interrupts to tasks in the kernel</a></li>
<li><a href="#_kernel_reserved_interrupts">4.5. Kernel reserved interrupts</a></li>
</ul>
</li>
<li><a href="#timers">5. Timers</a>
<ul class="sectlevel2">
<li><a href="#_timestamp_format">5.1. Timestamp format</a></li>
<li><a href="#_programmers_model">5.2. Programmer&#8217;s model</a></li>
<li><a href="#_timer_control_operations">5.3. Timer control operations</a></li>
<li><a href="#_using_the_timer_to_implement_sleep">5.4. Using the timer to implement <code>sleep</code></a></li>
<li><a href="#_multiplexing_your_multiplexed_timer">5.5. Multiplexing your multiplexed timer</a></li>
</ul>
</li>
<li><a href="#_startup">6. Startup</a>
<ul class="sectlevel2">
<li><a href="#_from_reset_to_rust">6.1. From reset to Rust</a></li>
<li><a href="#_main_bring_your_own">6.2. <code>main</code>: bring your own</a></li>
<li><a href="#_starting_the_kernel">6.3. Starting the kernel</a></li>
<li><a href="#_starting_the_first_tasks">6.4. Starting the first task(s)</a></li>
</ul>
</li>
<li><a href="#_hubris_syscalls">7. Hubris Syscalls</a>
<ul class="sectlevel2">
<li><a href="#_syscall_abi">7.1. Syscall ABI</a>
<ul class="sectlevel3">
<li><a href="#_armv6_m_armv7_m_armv8_m">7.1.1. ARMv6-M / ARMv7-M / ARMv8-M</a></li>
<li><a href="#_risc_v">7.1.2. RISC-V</a></li>
</ul>
</li>
<li><a href="#_syscalls">7.2. Syscalls</a>
<ul class="sectlevel3">
<li><a href="#sys_send">7.2.1. <code>SEND</code> (0)</a></li>
<li><a href="#sys_recv">7.2.2. <code>RECV</code> (1)</a></li>
<li><a href="#sys_reply">7.2.3. <code>REPLY</code> (2)</a></li>
<li><a href="#sys_set_timer">7.2.4. <code>SET_TIMER</code> (3)</a></li>
<li><a href="#sys_borrow_read">7.2.5. <code>BORROW_READ</code> (4)</a></li>
<li><a href="#sys_borrow_write">7.2.6. <code>BORROW_WRITE</code> (5)</a></li>
<li><a href="#sys_borrow_info">7.2.7. <code>BORROW_INFO</code> (6)</a></li>
<li><a href="#sys_irq_control">7.2.8. <code>IRQ_CONTROL</code> (7)</a></li>
<li><a href="#_panic_8">7.2.9. <code>PANIC</code> (8)</a></li>
<li><a href="#sys_get_timer">7.2.10. <code>GET_TIMER</code> (9)</a></li>
<li><a href="#_refresh_task_id_10">7.2.11. <code>REFRESH_TASK_ID</code> (10)</a></li>
<li><a href="#_post_11">7.2.12. <code>POST</code> (11)</a></li>
<li><a href="#_reply_fault_12">7.2.13. <code>REPLY_FAULT</code> (12)</a></li>
<li><a href="#sys_irq_status">7.2.14. <code>IRQ_STATUS</code> (13)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_the_kernel_ipc_interface">8. The Kernel IPC Interface</a>
<ul class="sectlevel2">
<li><a href="#_sending_messages_to_the_kernel">8.1. Sending messages to the kernel</a>
<ul class="sectlevel3">
<li><a href="#_read_task_status_1">8.1.1. <code>read_task_status</code> (1)</a></li>
<li><a href="#_reinit_task_2">8.1.2. <code>reinit_task</code> (2)</a></li>
<li><a href="#_fault_task_3">8.1.3. <code>fault_task</code> (3)</a></li>
<li><a href="#_read_image_id_4">8.1.4. <code>read_image_id</code> (4)</a></li>
<li><a href="#_reset_5">8.1.5. <code>reset</code> (5)</a></li>
<li><a href="#_get_task_dump_region_6">8.1.6. <code>get_task_dump_region</code> (6)</a></li>
<li><a href="#_read_task_dump_region_7">8.1.7. <code>read_task_dump_region</code> (7)</a></li>
<li><a href="#_software_irq_8">8.1.8. <code>software_irq</code> (8)</a></li>
<li><a href="#_find_faulted_task_9">8.1.9. <code>find_faulted_task</code> (9)</a></li>
</ul>
</li>
<li><a href="#_receiving_from_the_kernel">8.2. Receiving from the kernel</a></li>
</ul>
</li>
<li><a href="#_application_notes">9. Application Notes</a>
<ul class="sectlevel2">
<li><a href="#_servers">9.1. Servers</a>
<ul class="sectlevel3">
<li><a href="#_the_role_of_a_server">9.1.1. The role of a server</a></li>
<li><a href="#uphill-send">9.1.2. Servers are clients too</a></li>
<li><a href="#_when_not_to_use_a_server">9.1.3. When <em>not</em> to use a server</a></li>
<li><a href="#_low_level_syscall_implementation">9.1.4. Low-level (syscall) implementation</a></li>
<li><a href="#_high_level_wrapper_implementation">9.1.5. High-level (wrapper) implementation</a></li>
<li><a href="#_api_wrapper_crates">9.1.6. API wrapper crates</a></li>
<li><a href="#_pipelining">9.1.7. Pipelining</a></li>
</ul>
</li>
<li><a href="#supervisor">9.2. Supervision</a>
<ul class="sectlevel3">
<li><a href="#_what_is_the_supervisor">9.2.1. What is the supervisor?</a></li>
<li><a href="#_what_does_the_supervisor_do">9.2.2. What does the supervisor do?</a></li>
<li><a href="#_talking_to_the_supervisor">9.2.3. Talking to the supervisor</a></li>
</ul>
</li>
<li><a href="#drivers">9.3. Drivers</a>
<ul class="sectlevel3">
<li><a href="#_driver_crate_vs_server">9.3.1. Driver crate vs server</a></li>
<li><a href="#_high_level_server">9.3.2. High Level Server</a></li>
<li><a href="#_driver_api_crates">9.3.3. Driver API crates</a></li>
</ul>
</li>
<li><a href="#caboose">9.4. The caboose</a></li>
</ul>
</li>
<li><a href="#_references">References</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hubris is a small operating system intended for deeply-embedded computer systems&#8201;&#8212;&#8201;the kind that usually don&#8217;t have any user interface, or way for an operator
to intervene. Because it&#8217;s important for systems like that to take care of
themselves, Hubris is designed around the goal of <em>robustness.</em></p>
</div>
<div class="sect2">
<h3 id="_obligatory_bulleted_list_of_features">1.1. Obligatory bulleted list of features</h3>
<div class="ulist">
<ul>
<li>
<p>Designed for 32-bit microcontrollers with region-based memory protection and
kiB to MiB of RAM and Flash.</p>
</li>
<li>
<p><a href="#tasks">Tasks</a> are separately-compiled programs, isolated from one another in
memory, and running entirely in the processor&#8217;s unprivileged mode(s).</p>
</li>
<li>
<p>A flexible <a href="#ipc">IPC model</a> allows tasks to talk to each other.</p>
</li>
<li>
<p>A small kernel running in privileged mode provides these abstractions and very
little else.</p>
</li>
<li>
<p><a href="#drivers">Drivers live in tasks</a>, not the kernel.</p>
</li>
<li>
<p>All task mechanisms are designed to allow component-level reboots without
taking out the whole system, under application control.</p>
</li>
<li>
<p>One &#8220;special task,&#8221; <a href="#supervisor">the <em>supervisor,</em></a> implements all task
management and crash recovery policies, outside the kernel. (Applications are
free to provide their own supervisor.)</p>
</li>
<li>
<p>Applications ship as integral firmware images, containing a set of tasks and
the kernel built at the same time. Piecewise update of tasks, or creation of
new tasks at runtime, is deliberately not supported.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_architecture">1.2. Architecture</h3>
<div class="paragraph">
<p>An <em>application</em> using Hubris consists of a collection of <em>tasks</em> and the Hubris
<em>kernel.</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre>+---------+ +---------+ +---------+ +---------+  \
|  task   | |  task   | |  task   | |  task   |   |
+---------+ +---------+ +---------+ +---------+   |
+---------+ +---------+ +---------+ +---------+   |
|  task   | |  task   | |  task   | |  task   |   | application
+---------+ +---------+ +---------+ +---------+   |
                                                  |
+---------------------------------------------+   |
|                kernel                       |   |
+---------------------------------------------+  /</pre>
</div>
</div>
<div class="paragraph">
<p>The Hubris build system compiles the tasks and kernel with features chosen by
a configuration file called <code>app.toml</code>, which defines the structure of the
particular application. The scheme is designed so that tasks can be written to
be somewhat generic, and then customized for the application.</p>
</div>
<div class="paragraph">
<p>An application is the unit of firmware that is shipped and flashed. We do not
support updating <em>parts</em> of an application in the field. This is to ensure that
we&#8217;ve tested the particular combination of parts that we ship. This decision has
a lot of implications on the design of the rest of the system&#8201;&#8212;&#8201;for instance,
there is no particular requirement for inter-task ABIs to be stable if all tasks
will be rebuilt together.</p>
</div>
<div class="paragraph">
<p>Finally, an important thing to know about Hubris&#8217;s architecture is that it is a
<em>physically addressed</em> system. Each task&#8217;s memory occupies separate,
non-overlapping sections of address space, and the kernel has its own section.
This is different from most memory-protected operating systems, like Unix or
Windows, where each program is allowed to believe it occupies the entire address
space, through hardware trickery. We initially chose to make Hubris physically
mapped out of necessity: the low-complexity low-cost microcontrollers we target
simply do not have virtual memory mapping hardware. However, it turns out that
having all application components visible in a single address space makes
debugging <em>dramatically</em> simpler. As a result, we currently intend to keep the
system physically mapped, even if we port to a processor with virtual addressing
support.</p>
</div>
</div>
<div class="sect2">
<h3 id="_philosophy">1.3. Philosophy</h3>
<div class="sect3">
<h4 id="_toward_robustness">1.3.1. Toward robustness</h4>
<div class="paragraph">
<p>We&#8217;re trying to inch closer to robustness than our previous systems could,
through a combination of decisions.</p>
</div>
<div class="paragraph">
<p><strong>More memory safety.</strong> The bulk of both the Hubris kernel and our applications
are written in safe Rust, with careful sprinklings of unsafe Rust where
required. &#8220;Unsafe&#8221; Rust is still a much safer language than C or assembler and
helps us avoid thinking about a bunch of potential bugs.</p>
</div>
<div class="paragraph">
<p><strong>Fault isolation.</strong> Tasks, including drivers, can crash independently. An
application might choose to have a driver crash ripple out into clients, but
could also choose to notify clients and have them retry requests&#8201;&#8212;&#8201;whichever is
appropriate. Memory protection is vital for ensuring this; without it, once some
invariant in the system is observed to be broken, you have to assume they&#8217;re all
in jeopardy.</p>
</div>
<div class="paragraph">
<p><strong>Holistic deployment.</strong> It&#8217;s critical to ship the code you test, but once a
program has been factored into a bunch of separately compiled pieces, there&#8217;s a
temptation to update each of these pieces independently. This leads to a
combinatorial explosion in the configurations you&#8217;d have to test to be thorough.
To avoid that, engineering processes pick up a lot of overhead about conscious
forward- and backward-compatible API design, etc. We&#8217;ve chosen to bypass this
and assume that all the software that runs on a given processor was built&#8201;&#8212;&#8201;and
tested!&#8201;&#8212;&#8201;together.</p>
</div>
</div>
<div class="sect3">
<h4 id="_pragmatism">1.3.2. Pragmatism</h4>
<div class="paragraph">
<p>There are a class of &#8220;ideal attractors&#8221; in engineering, concepts like
&#8220;everything is an object,&#8221; &#8220;homoiconicity,&#8221; &#8220;purely functional,&#8221; &#8220;pure
capability system,&#8221; etc. Engineers fall into orbit around these ideas quite
easily. Systems that follow these principles often get useful properties out of
the deal.</p>
</div>
<div class="paragraph">
<p>However, going too far in any of these directions is also a great way to find a
deep reservoir of unsolved problems, which is part of why these are popular
directions in academia.</p>
</div>
<div class="paragraph">
<p>In the interest of shipping, we are consciously steering around unsolved
problems, even when it means we lose some attractive features. For instance:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>While we expect interrupts to be handled in unprivileged tasks in general, we
have left allowances for applications to handle interrupts in lower-latency
but more-dangerous privileged code if required.</p>
</li>
<li>
<p>While we&#8217;re bullish on Hubris&#8217;s ability to enforce system-wide <code>W^X</code>&#8201;&#8212;&#8201;that
is, having no executable sections of the address space writable or vice versa&#8201;&#8212;&#8201;this is not mandatory, in case you need to do something we didn&#8217;t foresee.</p>
</li>
<li>
<p>We have chosen fixed system-level resource allocation rather than dynamic,
because doing dynamic properly in a real-time system is hard. Yes, we are
aware of work done in capability-based memory accounting, space banks, and the
like.</p>
</li>
<li>
<p>Speaking of capabilities, in the security sense, Hubris doesn&#8217;t use any. The
only object of note in the system is the task, and any task can look up and
talk to any other task; we plan to address the most obvious issues with that
statement using mandatory access control. Capabilities raise issues around
revocation, proxying, branding, etc. that can yield useful results but don&#8217;t
seem necessary for our application.</p>
</li>
<li>
<p>We have (so far) not done any kind of inter-task type system relying on
session types and the like.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_implementation">1.3.3. Implementation</h4>
<div class="paragraph">
<p>We are doing our best to avoid writing code.</p>
</div>
<div class="paragraph">
<p>That might seem like an odd statement coming from a group that has written an
operating system from whole-cloth, and it is.</p>
</div>
<div class="paragraph">
<p>Adding code to a system like this adds attack surface, new corner cases that
must be tested, things the programmer has to reason about, and&#8201;&#8212;&#8201;most mundanely&#8201;&#8212;&#8201;more code we have to understand and maintain.</p>
</div>
<div class="paragraph">
<p>We&#8217;re working hard to avoid adding features to the lower layers of the system,
even when it takes a little more work at higher levels to compensate. For
instance, the original Hubris proposal included a MINIX-3-inspired asynchronous
messaging primitive for use by the supervisor task; we&#8217;re conscious of the
massive impact this would have on the system, and have been going out of our way
to avoid implementing it.</p>
</div>
<div class="paragraph">
<p>Now, that being said: we are doing our best to ensure that the code we <em>do</em>
write is correct.</p>
</div>
<div class="paragraph">
<p>In many ways, Rust makes this part of the job easy, but &#8220;cowboy coding&#8221; is as
feasible in Rust as in other languages, given a sufficiently motivated cowboy.
Culturally, we try to avoid being &#8220;clever&#8221; in pursuit of a few saved bytes or
cycles, and instead solve problems in ways that are more likely to be correct.
We also prize correctness by construction where possible, meaning, designing
pieces of the system such that illegal or undesirable states simply can&#8217;t be
represented, and defining operations that compose in predictable and useful ways
that can be discovered by applying local reasoning.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tasks">2. Tasks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Other than the kernel, all the code in a Hubris application lives in one or more
<em>tasks.</em> Tasks are programs that run in the processor&#8217;s <em>unprivileged mode,</em>
subject to memory isolation. This means that tasks cannot directly stomp on
memory owned by the kernel, or each other.</p>
</div>
<div class="sect2">
<h3 id="_a_brief_note_on_priorities">2.1. A brief note on priorities</h3>
<div class="paragraph">
<p>Tasks have priorities, which are currently fixed at build time. These are small
integers.</p>
</div>
<div class="paragraph">
<p>Priorities are numbered in a way that may feel backwards: 0 is the highest
priority, 1 is the next highest, and so forth. In general, when we talk about
something being &#8220;higher priority,&#8221; we mean its priority number is numerically
smaller.</p>
</div>
</div>
<div class="sect2">
<h3 id="_scheduling">2.2. Scheduling</h3>
<div class="paragraph">
<p>The kernel is responsible for scheduling tasks by swapping between them as
needed. At any given time, one task has control of the CPU, and the others are
<em>blocked.</em></p>
</div>
<div class="paragraph">
<p>Hubris uses a strict priority scheduling method: the kernel ensures that, at any
given time, the highest-priority task that is ready to run has control of the
CPU. If that task becomes ready while another task is running&#8201;&#8212;&#8201;say, due to an
interrupt&#8201;&#8212;&#8201;the kernel will preempt the lower priority task and switch to the
higher priority task.</p>
</div>
<div class="paragraph">
<p>Within a single priority level, multitasking is effectively cooperative: the
kernel will never interrupt a task to switch to another task of equal or lower
priority, until that task performs an operation that yields the CPU, such as
sending a message or blocking to receive messages that haven&#8217;t arrived yet. The
alternative to this is to implement <em>time-slicing,</em> where a task gets a fixed
amount of time before another task at the same priority will have the
opportunity to run; we chose not to implement this.</p>
</div>
<div class="paragraph">
<p>Priority levels in Hubris are effectively unlimited (currently, there are up to
256 of them), and using more levels has no runtime cost&#8201;&#8212;&#8201;so, if the absence of
time-slicing is a problem for your application, you can use a single task per
priority level and get full preemption.</p>
</div>
</div>
<div class="sect2">
<h3 id="_separate_compilation">2.3. Separate compilation</h3>
<div class="paragraph">
<p>Tasks are <em>separately compiled</em> and do not share code. This is both good and
bad. Some advantages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Libraries that, for whatever reason, use static global data can&#8217;t accidentally
propagate failures from one task to another.</p>
</li>
<li>
<p>Each task can customize the libraries it uses with different feature flags,
without unexpected effects on other tasks.</p>
</li>
<li>
<p>Tasks can use totally different compiler optimization levels.</p>
</li>
<li>
<p>Tasks can, in theory, be written in entirely different programming languages,
from assembler to C to Rust.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The main disadvantage is that it makes the application <em>bigger.</em> If three tasks
all use the <code>useful_code</code> library, the application will contain three copies of
that library&#8217;s code in Flash.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We could improve this situation by introducing an equivalent to shared
libraries&#8201;&#8212;&#8201;something similar to another physically addressed system, such as
early versions of <a href="https://en.wikipedia.org/wiki/OS-9">Microware OS9</a>. This would
be a significant amount of work because all the off the shelf tooling we have
access to assumes that shared libraries go hand in hand with virtual
addressing. So, we have punted for now.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="immortal">2.4. Tasks can&#8217;t be created or destroyed</h3>
<div class="paragraph">
<p>An application declares all of its tasks in its <code>app.toml</code> config file, which
the build system processes to make an application image. The set of tasks
declared in that file is the set of tasks the application has, period. Unlike
most operating systems, Hubris does not support creating new tasks at runtime or
destroying existing tasks. This is on purpose. Task creation is a common source
of hard-to-account-for dynamic resource usage, which can enable denial of
service attacks.</p>
</div>
<div class="paragraph">
<p>Put another way, you can&#8217;t write a fork-bomb without fork.</p>
</div>
<div class="paragraph">
<p>This has a bunch of advantages, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It simplifies very important kernel code and data structures used to keep
track of tasks.</p>
</li>
<li>
<p>It means we can check the peak memory consumption of the system under load <em>at
compile time,</em> since there&#8217;s no way to create tasks in response to load.</p>
</li>
<li>
<p>It makes the addresses of tasks in physical memory predictable, simplifying
the debugger.</p>
</li>
<li>
<p>Tasks can size data structures based on the fixed number of tasks in the
system, if required. (This is used in <a href="#supervisor">supervisor tasks</a> and in
our prototype network stack.)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It <em>does</em> put some requirements on your design of applications, however, if
you&#8217;re accustomed to being able to clone tasks in response to load. Hubris
applications tend to be somewhat economical with tasks, such as by having a
single task process multiple streams of data, so that the task&#8217;s resources can
be bounded no matter how many streams arrive.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
While tasks can&#8217;t be destroyed, they <em>can</em> be halted due to faults or
other events. More on that below.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_failure_and_supervision">2.5. Failure and supervision</h3>
<div class="paragraph">
<p>Hubris is built on the assumption that individual tasks may <em>fail.</em> A task fails
by causing a <em>fault</em>&#8201;&#8212;&#8201;or, more precisely, by taking an action that causes the
kernel to assign a fault to it. There are a wide variety of faults in Hubris,
and they fall into three main categories:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Hardware faults.</strong> Hardware faults are delivered by the CPU in response to
program actions. Examples include dereferencing a null pointer, trying to access
another task&#8217;s memory, jumping into non-executable RAM, and executing
instructions that are illegal in unprivileged mode.</p>
</li>
<li>
<p><strong>Syscall faults.</strong> Syscall faults occur when the task makes a syscall into
the kernel, and <em>does it wrong.</em> Programmer errors that are indicated with error
return codes in other operating systems are syscall faults in Hubris&#8201;&#8212;&#8201;under
the theory that misuse of a syscall indicates a failed, malfunctioning program.</p>
</li>
<li>
<p><strong>Explicit panics.</strong> Tasks may volunteer that they have failed by using a
syscall to panic. In Rust, this maps to the <code>panic!</code> macro.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Regardless of the source, when a task faults, it</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Immediately loses the CPU,</p>
</li>
<li>
<p>Has its state preserved to the extent possible, and</p>
</li>
<li>
<p>Has its fault recorded by the kernel.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hubris itself does not restart faulted tasks. Instead, a designated task called
the <em>supervisor</em> can be notified when a task faults and take action. Normally,
the supervisor&#8217;s response will be to read information about the fault from the
kernel, log that somewhere, and ask the kernel to <em>reinitialize</em> the failed
task, as described in the next section.</p>
</div>
<div class="paragraph">
<p>(For a more detailed look at supervisors, see <a href="#supervisor">Supervision</a>.)</p>
</div>
</div>
<div class="sect2">
<h3 id="_initialization_and_re_initialization">2.6. Initialization and re-initialization</h3>
<div class="paragraph">
<p>At boot, the Hubris kernel sets some number of tasks to run. (The application
can designate which tasks to start at boot in its <code>app.toml</code>.) Later, the kernel
may need to restart failed tasks, on request from the supervisor. Hubris
deliberately uses the same code path for both of these operations.</p>
</div>
<div class="paragraph">
<p>The steps taken when (re)initializing a task are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Increment the task&#8217;s <em>generation number.</em> This is a small counter kept on
each task that tracks restarts.</p>
</li>
<li>
<p>Identify any <em>other</em> tasks that were blocked interacting with this task&#8217;s
previous generation. Unblock them, delivering a recognizable error code to tell
them what happened. (More on this in <a href="#death">Death and IPC</a>.)</p>
</li>
<li>
<p>Reset the task&#8217;s registers to their initial values, which were chosen at
compile time based on information in the <code>app.toml</code>.</p>
</li>
<li>
<p>Reset the task&#8217;s timer. (Timers will be discussed in the section <a href="#timers">Timers</a>.)</p>
</li>
<li>
<p>&#8220;Scribble&#8221; the task&#8217;s stack memory with a recognizable pattern. This helps
catch accesses to uninitialized stack memory (in languages other than Rust, or
excessively clever Rust) and can be used by the debugger to determine each
task&#8217;s actual peak stack usage, by looking for how much of it has been
overwritten.</p>
</li>
<li>
<p>Mark the task as runnable.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>It&#8217;s worth noting a few things that the kernel does <em>not</em> do during reinit:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The task&#8217;s memory protection configuration in the kernel is left unchanged,
since there are no APIs changing a task&#8217;s memory protections.</p>
</li>
<li>
<p>It doesn&#8217;t initialize the task&#8217;s <code>data</code> or zero its <code>bss</code>. We leave this to
the task itself, so that we don&#8217;t make too many assumptions about task
internal memory layout. (For programs written in Rust, this is handled by the
<code>_start</code> routine in <code>userlib</code> before execution reaches <code>main</code>.)</p>
</li>
<li>
<p>It doesn&#8217;t do anything to the task&#8217;s executable code, which is assumed to be
in execute-in-place Flash and immutable. (Hubris has no equivalent to a
&#8220;loader.&#8221;)</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ipc">3. IPC</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hubris IPC (inter-process communication) provides a mechanism for communicating
between tasks. It&#8217;s designed to be easy to reason about, and to work well with
Rust&#8217;s ownership model.</p>
</div>
<div class="paragraph">
<p>This chapter takes a high-level look at IPC in Hubris, which can be broken apart
into four pieces:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>How to send messages,</p>
</li>
<li>
<p>How to receive and handle messages,</p>
</li>
<li>
<p>How those two bits interact with task restarts, and</p>
</li>
<li>
<p>Notifications, an alternative lighter-weight IPC mechanism.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In practice, most code you write on Hubris will be using various abstractions or
wrapper libraries that obscure the specifics of IPC. However, we think it&#8217;s
important to understand what&#8217;s really going on, even if you choose to mostly use
it through a library&#8201;&#8212;&#8201;and besides, somebody has to write those libraries, and
that could easily be you. So in this chapter, we&#8217;ll peel back the abstractions
and deal in the raw IPC operations provided by the kernel.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
IPC is technically a misnomer, since we don&#8217;t have what most folks think
of as &#8220;processes&#8221; (the P in IPC). But hey. Inter-Task Communication just
isn&#8217;t as catchy.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_synchronous_ipc_basics">3.1. Synchronous IPC basics</h3>
<div class="paragraph">
<p>Hubris IPC is based around <em>synchronous messaging.</em> Communication between tasks
consists of sending and receiving messages. Sending a message always blocks the
sender, waiting for a reply. A task that asks to receive a message will block
if no messages are available. In the common case, the sequence is</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The recipient task, B, finishes doing something else and asks to receive.</p>
</li>
<li>
<p>It is blocked by the kernel, allowing other tasks to run.</p>
</li>
<li>
<p>The sending task, A, prepares a message to B and asks to send.</p>
</li>
<li>
<p>Task A is marked as blocked and task B is resumed to process the message.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When two tasks align in this way, a <em>message transfer</em> occurs. This is an
action performed by the kernel on behalf of the two tasks. During a message
transfer, the kernel copies a small data payload (the <em>message</em>) from the
sender to the recipient, and provides the recipient with some metadata it can
use to process the message.</p>
</div>
<div class="paragraph">
<p>This style of messaging is also called a <em>rendezvous</em> or <em>handoff,</em> because both
tasks need to arrange to &#8220;meet&#8221; in the right state for the message transfer
to happen.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In case you&#8217;re concerned that all messages are small, you will be relieved
to know that we have a mechanism for dealing with that; if you want to skip
ahead, see <a href="#leases">Lending out memory</a>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_why_synchronous">3.1.1. Why synchronous?</h4>
<div class="paragraph">
<p>This is not the only way to design an IPC system. The main alternatives involve
some sort of asynchrony or queueing, where a task can issue several messages and
then do other work while waiting for responses. This can be useful, so it&#8217;s
worth asking why Hubris is fully synchronous.</p>
</div>
<div class="paragraph">
<p>It turns out that synchronous IPC has significant advantages for systems like
Hubris.</p>
</div>
<div class="paragraph">
<p><strong>It&#8217;s fast.</strong> Synchronous IPC can be implemented using a single message copy
from sender to recipient. The message need only be read once. This reduces the
number of clock cycles required for a message transfer. (The operating system
that originally made this point was L4, and Hubris&#8217;s IPC mechanism is directly
inspired by L4&#8217;s.)</p>
</div>
<div class="paragraph">
<p><strong>There are no queues to size.</strong> Asynchronous systems usually queue messages in
kernel memory, which means there are now kernel-managed queues that must have
their resources accounted for. In extreme cases, this can allow a single task to
exhaust the kernel&#8217;s memory with impunity by expanding queues to the breaking
point&#8201;&#8212;&#8201;which isn&#8217;t great for reliability. Many systems that try to avoid that
problem do so by allowing the user to impose size limits on queues, which then
become another thing users need to tune carefully for best performance. With
synchronous rendezvous messaging, we avoid having queues in the first place.</p>
</div>
<div class="paragraph">
<p><strong>It limits the power of any single task.</strong> A Hubris task can either be doing
local work, or sending one message. It can&#8217;t, for instance, spam every other
task in the system with messages simultaneously, or set up hundreds of messages
to a single task. This avoids &#8220;fault amplification&#8221; scenarios where a bug in
one task cascades into a much larger problem, as in a denial-of-service attack.</p>
</div>
<div class="paragraph">
<p><strong>It lets message recipients reason about what their callers are doing.</strong> When
your task is processing a message, it knows that the sending task is parked
waiting for a reply.<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup> It also knows that, if it goes to receive a <em>second</em>
message before replying, that message won&#8217;t be from the same task. This allows
message recipients to coordinate when senders run and don&#8217;t run, which is useful
for implementing mutual exclusion, as we&#8217;ll discuss later.</p>
</div>
<div class="paragraph">
<p>Finally, <strong>synchronous IPC makes the system much easier to think about.</strong> Each
task operates as a synchronous state machine, with IPC operations appearing as
atomic and predictably ordered. Larger systems composed out of tasks can be
easily halted and inspected to see who&#8217;s waiting on who. Lots of potential race
conditions are eliminated. We&#8217;ve found this point to be hugely important during
our early experience with the system.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You may be wondering about deadlocks in synchronous IPC. We avoid IPC-level deadlocks and priority inversion by imposing rules around messaging and task priority. This makes IPC-level deadlock impossible, but of course you can still write software that deadlocks if you try. More on this in the section <a href="#uphill-send">Servers are clients too</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sending_messages">3.2. Sending messages</h3>
<div class="paragraph">
<p>To simply consume IPC services implemented by others, there&#8217;s only one operation
you need to consider: <a href="#sys_send"><code>send</code></a>. <code>send</code> operates a lot like a function
call:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It takes some arguments,</p>
</li>
<li>
<p>It returns some results,</p>
</li>
<li>
<p>It pauses your code (the caller) until it returns.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To use <code>send</code>, you specify the task you&#8217;re sending to, and an <strong>operation code</strong>
that tells that task what operation you&#8217;re trying to invoke. (A given API will
document which operation codes are used.)</p>
</div>
<div class="paragraph">
<p>In Rust, <code>send</code> has the following signature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">fn</span> <span class="nf">sys_send</span><span class="p">(</span>
    <span class="n">target</span><span class="p">:</span> <span class="n">TaskId</span><span class="p">,</span>       <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">operation</span><span class="p">:</span> <span class="nb">u16</span><span class="p">,</span>       <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">outgoing</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span>      <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="n">incoming</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span>  <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="n">leases</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">Lease</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">],</span> <i class="conum" data-value="5"></i><b>(5)</b>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">u32</span><span class="p">,</span> <span class="nb">usize</span><span class="p">);</span>        <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>TaskId</code> of the task you&#8217;re trying to contact.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <em>operation code</em> giving the operation you&#8217;re requesting.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The message you wish to send.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>A buffer where any message sent in response will be deposited.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Zero or more <em>leases,</em> which we&#8217;ll discuss below in the section <a href="#leases">Lending out memory</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Returns a <code>u32</code> giving the <em>response code</em> and a <code>usize</code> saying how many
bytes were written into <code>incoming</code>. These will both be described below in
the section <a href="#response-codes">Response codes and <code>Result</code></a>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The simplest case for <code>send</code> is when you&#8217;re sending a small payload (say, a
<code>struct</code>) and receiving a small response (say, another <code>struct</code>), and the
recipient/callee is already blocked waiting for messages:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Your task invokes <code>send</code>, providing the <code>target</code> (recipient task) and
<code>operation</code>, as well as the message to send (<code>outgoing</code>) as a <code>&amp;[u8]</code>. It
also provides a buffer where the response should be deposited (<code>incoming</code>),
as a <code>&amp;mut [u8]</code>.</p>
</li>
<li>
<p>The kernel notices that the recipient is waiting for messages, and directly
copies your message (operation code and payload data) from your task&#8217;s
memory into the callee&#8217;s.</p>
</li>
<li>
<p>The kernel then marks your task as blocked waiting for reply, and unblocks
the recipient, informing it that a message has arrived.</p>
</li>
<li>
<p>The recipient does some work on your behalf.</p>
</li>
<li>
<p>It then uses the <code>reply</code> operation to send a response message back. (<code>reply</code>
will be covered soon in the section <a href="#recv-and-reply">Receiving and handling messages</a>).</p>
</li>
<li>
<p>The kernel copies the response message into the <code>incoming</code> buffer your task
provided, makes <code>send</code>'s two result values available to your task, and
marks your task as runnable.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If the recipient is <em>not</em> already waiting for messages when your task tries to
send, the process is similar, except that your task may be blocked waiting to
send for an arbitrary period between steps 1 and 2.</p>
</div>
<div class="paragraph">
<p>Note that the kernel doesn&#8217;t <em>interpret</em> either the operation code or the
message data flowing between tasks. Any meaning there is defined by the
application. The kernel looks only at the task IDs, and copies the rest blindly
from place to place.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The Hubris source code sometimes refers to operation codes as
&#8220;selectors&#8221; or &#8220;discriminators,&#8221; because Cliff can&#8217;t make up his mind on
which metaphor to use.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="response-codes">3.2.1. Response codes and <code>Result</code></h4>
<div class="paragraph">
<p>From the caller&#8217;s perspective, <code>send</code> deposits any returned data into the
<code>incoming</code> buffer given to <code>send</code>. But it also returns two integers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <strong>response code.</strong></p>
</li>
<li>
<p>The <strong>length</strong> of data deposited in the return buffer.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The response code, like the operation code, is largely application-defined, but
it&#8217;s <em>intended</em> to be used to distinguish success from error. Specifically, <code>0</code>
meaning success, and non-zero meaning error.</p>
</div>
<div class="paragraph">
<p>The length gives the number of bytes in the <code>incoming</code> buffer that have been
written by the kernel and are now valid. This happens no matter what the
response code is, so an operation can return detailed data even in the case of
an error.</p>
</div>
<div class="paragraph">
<p>This scheme is specifically designed to allow IPC wrapper functions to translate
the results of <code>send</code> into a Rust <code>Result&lt;T, E&gt;</code> type, where <code>T</code> is built from
the data returned on success, and <code>E</code> is built from the combination of the
non-zero response code and any additional data returned. Most wrappers do this.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
While response codes are <em>mostly</em> up to the application, there is a class
of non-zero response codes used by the kernel to indicate certain failure cases
related to crashing tasks. These are called &#8220;dead codes,&#8221; and will be covered
later, in the section <a href="#death">Death and IPC</a>. Applications should choose their response codes
to avoid colliding with them. Fortunately, they&#8217;re very large numbers, so if
applications start their errors from 1 they should be safe.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_message_size_limits">3.2.2. Message size limits</h4>
<div class="paragraph">
<p>When a message transfer happens, the kernel diligently copies the message data
from one place to another. This operation is uninterruptible, so it may delay
processing of interrupts or timers. To limit this, we impose a maximum length on
messages, currently 256 bytes.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you need to move more data than this, you can use the &#8220;lease&#8221;
mechanism, described in the next section.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="leases">3.2.3. Lending out memory</h4>
<div class="paragraph">
<p>Sending and receiving small structs by copy is a good start, but what if you
want something more complex? For example, how do you send 1kiB of data to a
serial port, or read it back, when messages are limited to 256 bytes?</p>
</div>
<div class="paragraph">
<p>The answer is the same as in Rust: when you call the operation, you loan it some
of your memory.</p>
</div>
<div class="paragraph">
<p>Any <code>send</code> operation can include <strong>leases</strong>, which are small descriptors that tell
the kernel to allow the <em>recipient of the message</em> to access parts of the
<em>sender&#8217;s</em> memory space. Each lease can be read-only, write-only, or read-write.
While the sender is waiting for a reply, the recipient has exclusive control of
the leased memory it is borrowing. If the caller resumes (generally after
<code>reply</code>, but also possible in some corner cases involving task supervision) the
leases are reliably and atomically <em>revoked</em>.</p>
</div>
<div class="paragraph">
<p>This means it&#8217;s safe to lend out any memory that the caller can safely access,
including memory from the caller&#8217;s stack.</p>
</div>
<div class="paragraph">
<p>This property also means that lending data can be expressed, in Rust, as simple
<code>&amp;</code> or <code>&amp;mut</code> borrows, and checked for correctness at compile time.</p>
</div>
<div class="paragraph">
<p>Each <code>send</code> can include up to 255 leases (currently&#8201;&#8212;&#8201;this number may be
reduced because what on earth do you need that many leases for).</p>
</div>
<div class="paragraph">
<p>On the recipient side, leases are referred to by index (0 through 255), and an
IPC operation would typically declare that it needs certain arguments passed as
leases in a certain order. For instance, a simple serial write operation might
expect a single readable lease giving the data to send, while a more nuanced I2C
operation might take a sequence of readable and writable leases.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
An operation can also take a <em>variable</em> number of leases and use this to
implement scatter-gather. It&#8217;s up to the designer of the API.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_making_this_concrete">3.2.4. Making this concrete</h4>
<div class="paragraph">
<p>Let&#8217;s sketch a concrete IPC interface, to get a feeling for how the various
options on <code>send</code> fit together. Imagine a task that implements a very simple
streaming data access protocol consisting of two functions (written as in Rust):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">fn</span> <span class="nf">read</span><span class="p">(</span><span class="n">fd</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">buffer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="n">IoError</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="n">fd</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">buffer</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="n">IoError</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">IoError</span> <span class="p">{</span>
    <span class="n">Eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">ContainedBobcat</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>These are basically POSIX read and write, only expressed in Rust style.</p>
</div>
<div class="paragraph">
<p>A concrete mapping of these operations to IPCs might go as follows.</p>
</div>
<div class="paragraph">
<p><strong>Read.</strong> Operation code 0.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Message is a four-byte struct containing <code>fd</code> as a little-endian <code>u32</code>. Borrow
0 is <code>buffer</code> and must be writable.</p>
</li>
<li>
<p>Data will be written to a prefix of lease 0, starting at offset 0.</p>
</li>
<li>
<p>On success, returns response code 0 and a four-byte response, containing the
bytes-read count as a little-endian <code>u32</code>.</p>
</li>
<li>
<p>On failure, returns a non-zero response code that maps to an <code>IoError</code>, and a
zero-length response message.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Write.</strong> Operation code 1.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Message is a four-byte struct containing <code>fd</code> as a little-endian <code>u32</code>. Borrow
0 is <code>buffer</code> and must be readable.</p>
</li>
<li>
<p>Data will be taken from a prefix of lease 0, starting at offset 0.</p>
</li>
<li>
<p>On success, returns response code 0 and a four-byte response, containing the
bytes-written count as a little-endian <code>u32</code>.</p>
</li>
<li>
<p>On failure, returns a non-zero response code that maps to an <code>IoError</code>, and a
zero-length response message.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Either of these operations could be altered to also return the number of
bytes read or written in an error case, by making the response non-empty and
changing the <code>IoError</code> type in Rust to have data fields.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A very simple IPC stub for the <code>read</code> operation might be written as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">use</span> <span class="nn">userlib</span><span class="p">::{</span><span class="n">TaskId</span><span class="p">,</span> <span class="n">FromPrimitive</span><span class="p">,</span> <span class="n">sys_send</span><span class="p">};</span>

<span class="nd">#[derive(Copy,</span> <span class="nd">Clone,</span> <span class="nd">Debug,</span> <span class="nd">FromPrimitive)]</span>
<span class="k">enum</span> <span class="n">IoError</span> <span class="p">{</span>
    <span class="n">Eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">ContainedBobcat</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">read</span><span class="p">(</span><span class="n">task</span><span class="p">:</span> <span class="n">TaskId</span><span class="p">,</span> <span class="n">fd</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">buffer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="n">IoError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">response</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">4</span><span class="p">];</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">=</span> <span class="nf">sys_send</span><span class="p">(</span>
        <span class="n">task</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">fd</span><span class="nf">.to_le_bytes</span><span class="p">(),</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="n">response</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="p">[</span><span class="nn">Lease</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">buffer</span><span class="p">)],</span>
    <span class="p">);</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">=</span> <span class="nn">IoError</span><span class="p">::</span><span class="nf">from_u32</span><span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="nn">u32</span><span class="p">::</span><span class="nf">from_le_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">response</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>(<code>write</code> would be nearly identical, but with the operation code changed.)</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="recv-and-reply">3.3. Receiving and handling messages</h3>
<div class="paragraph">
<p>To write a task that implements some IPC protocol, we need to be able to receive
and handle messages. There are two operations involved on this side:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#sys_recv"><code>recv</code></a> gets the next pending message, and</p>
</li>
<li>
<p><a href="#sys_reply"><code>reply</code></a> unblocks the sender of a message, optionally delivering
a response data payload.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">fn</span> <span class="nf">sys_recv_open</span><span class="p">(</span>
    <span class="n">buffer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span>
    <span class="n">notification_mask</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">RecvMessage</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">RecvMessage</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">sender</span><span class="p">:</span> <span class="n">TaskId</span><span class="p">,</span>           <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">pub</span> <span class="n">operation</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>           <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="k">pub</span> <span class="n">message_len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>       <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="k">pub</span> <span class="n">response_capacity</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="k">pub</span> <span class="n">lease_count</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>       <i class="conum" data-value="6"></i><b>(6)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>notification_mask</code> is used for a facility we haven&#8217;t described yet,
which will be covered below in <a href="#notifications">Notifications: the <em>other</em> IPC mechanism</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>sender</code> is the <code>TaskId</code> of the task that sent the message. This is provided
by the kernel and is reliable, i.e. there is no way for a task to lie here.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The operation code sent by the sender. (You might notice that this is 32
bits while the equivalent argument to <code>send</code> is only 16. This will <em>also</em> be
explained in the section <a href="#notifications">Notifications: the <em>other</em> IPC mechanism</a>.)</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Length of the sent message. If this is larger than <code>buffer.len()</code>, the
caller sent an over-long message that has been truncated, and you likely want to
return an error.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Number of bytes the caller reserved for receiving your reply.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Number of leases the caller sent you. You can get additional information
about these borrows using the <a href="#sys_borrow_info"><code>BORROW_INFO</code> (6)</a> syscall, and there are
additional syscalls for <a href="#sys_borrow_read">reading</a> and
<a href="#sys_borrow_write">writing</a>.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">fn</span> <span class="nf">sys_reply</span><span class="p">(</span><span class="n">peer</span><span class="p">:</span> <span class="n">TaskId</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>sys_reply</code> cannot fail. This will be unpacked in the next section.</p>
</div>
<div class="sect3">
<h4 id="_pipelining_out_of_order_replies_and_reply_failure">3.3.1. Pipelining, out-of-order replies, and reply failure</h4>
<div class="paragraph">
<p>Hubris does <em>not</em> require that you <code>reply</code> before calling <code>recv</code> again. You
could instead start an operation, do some bookkeeping to keep track of that
sender, and then <code>recv</code> the next, with the intent of replying later. This
allows you to implement a pipelined server that overlaps requests.</p>
</div>
<div class="paragraph">
<p>Hubris also doesn&#8217;t require that you <code>reply</code> in the same order as <code>recv</code>. For
example, in a pipelined server, you might want to promptly <code>reply</code> with an error
to a bogus request while still processing others. Or, in a fully asynchronous
server (such as a network stack for something like UDP), you might <code>reply</code>
whenever operations finish, regardless of their order.</p>
</div>
<div class="paragraph">
<p>Hubris doesn&#8217;t actually require that you <code>reply</code>, <em>ever.</em> The caller will wait
patiently. This means if you want to halt a task, sending a message to someone
who will never reply is a reasonable technique. Or, a server could halt
malfunctioning callers by never replying (see next section).</p>
</div>
<div class="paragraph">
<p>What <strong>is</strong> required for <code>reply</code> to succeed is that the sender must actually be
blocked in a send <em>to your task.</em> If you <code>reply</code> to a random task ID that has
never messaged you, the reply will not go through. If the sending task has been
forceably restarted by some supervising entity, the reply will not go through.
Similarly, if an application implements IPC timeouts by forceably unblocking
senders that have waited too long (something you can choose to do), the reply to
the timed-out sender won&#8217;t go through.</p>
</div>
<div class="paragraph">
<p>Because the latter two cases (sender timed out, sender rebooted) are expected to
be possible in an otherwise functioning application, and because it isn&#8217;t clear
in general how a server should handle a behavior error in one of its clients,
the <code>reply</code> operation <em>does not return an error to the server,</em> even if it
doesn&#8217;t go through. The server moves on.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This design decision copies MINIX 3, and those folks explained the
decision in much greater detail. See <a href="#herder08ipc">[herder08ipc]</a> for details, and
<a href="#shap03vuln">[shap03vuln]</a> for motivating history.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_handling_error_cases_on_receive">3.3.2. Handling error cases on receive</h4>
<div class="paragraph">
<p>Hubris assumes that you mistrust tasks sending you messages, and provides enough
information to detect the following error cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Unknown operation code.</p>
</li>
<li>
<p>Incoming message shorter or longer than what you expected, given the operation
code.</p>
</li>
<li>
<p>Wrong number of leases attached for the operation.</p>
</li>
<li>
<p>Sender&#8217;s response buffer too small to accommodate your reply.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Any of these suggest that the sender is confused or malfunctioning. You have a
few options for dealing with these cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Immediately <code>reply</code> to the sender with a non-zero response code and
zero-length message. Even if the sender is sending to the wrong task, the
convention around non-zero response codes means this is likely to be
interpreted as an error by the sender.</p>
</li>
<li>
<p><strong>Don&#8217;t</strong> reply. Leave the sender blocked, and instead notify some sort of
supervising entity of a potential malfunction. Or, depending on your
application architecture, just leave them blocked and expect a watchdog timer
to handle the problem if it matters.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="open-and-closed-recv">3.3.3. Open and closed receive</h4>
<div class="paragraph">
<p><code>recv</code> can operate in two modes, called <strong>open receive</strong> and <strong>closed receive</strong>.
The general case that we&#8217;ve been discussing so far is the open receive case.</p>
</div>
<div class="paragraph">
<p>In a closed receive, the task selects a single other task to receive messages
from. Any other sender will be blocked.</p>
</div>
<div class="paragraph">
<p>This can be used to implement mutual exclusion. If a client sends a lock request
to a server, for instance, the server could then perform a closed receive and
only accept messages from that client. Other clients could send lock requests,
but they&#8217;d queue up, until the first client either sends a &#8220;release&#8221; message,
or dies (see below).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="death">3.4. Death and IPC</h3>
<div class="paragraph">
<p>Tasks sometimes restart. For instance, the program running in a task may
<code>panic!</code> or dereference an invalid pointer, both of which produce a fault
against the task within the kernel. Normally, the supervisor task is expected
to notice this and reinitialize the failed task. When the task is restarted, a
number associated with the task, its <em>generation,</em> is incremented in the kernel.</p>
</div>
<div class="paragraph">
<p>The <code>TaskId</code> type used to designate tasks for IPC includes both a fixed
identifier for the task (its index) and this generation. The generation part of
the <code>TaskId</code> is checked on any IPC, and if it doesn&#8217;t match, the operation will
fail.</p>
</div>
<div class="paragraph">
<p>This is intended to detect cases where, during an exchange of messages between
two tasks, one restarts and the other doesn&#8217;t. Thanks to the generation
mechanism, the task that <em>didn&#8217;t</em> restart will get notified that the other task
<em>did.</em> It can then decide how to proceed&#8201;&#8212;&#8201;maybe the protocol between them is
stateless, and no action is needed, but often some kind of an init sequence may
be in order.</p>
</div>
<div class="paragraph">
<p>When an operation fails because of a generation mismatch, it returns a
predictable response code called a &#8220;dead code.&#8221; A dead code has its 24 top bits
set to 1, with the peer&#8217;s <em>new</em> generation number in the low 8. You can use this
to update your <code>TaskId</code> and retry your request, for instance.</p>
</div>
<div class="paragraph">
<p>The only currently defined IPC operations that can fail in this way are <code>send</code>
and the closed version of <code>receive</code>. <code>reply</code> does not check generations in
keeping with its fire-and-forget philosophy, and the open version of <code>receive</code>
doesn&#8217;t take a <code>TaskId</code> at all so there&#8217;s nothing to check.</p>
</div>
<div class="paragraph">
<p>It&#8217;s important to note that a generation mismatch may be detected at several
different points in time:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>When a message is initially sent.</p>
</li>
<li>
<p>After the sending task has blocked, but before the receiving task has noticed
the message.</p>
</li>
<li>
<p>After the message has been received, but before it&#8217;s been replied to.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>There&#8217;s currently no way for the sender to distinguish these cases, so, be
prepared for any of them.</p>
</div>
</div>
<div class="sect2">
<h3 id="notifications">3.5. Notifications: the <em>other</em> IPC mechanism</h3>
<div class="paragraph">
<p>In addition to synchronous messaging, Hubris also provides a very limited
asynchronous communication mechanism called <strong>notifications</strong>. Notifications are
designed to complement send-receive style IPC, and are intended for different
purposes. Generally, notifications are useful for situations where one might use
interrupts or signals in other systems.</p>
</div>
<div class="paragraph">
<p>Each task has 32 notification bits, which together form a <em>notification set</em>.
These bits can be <em>posted,</em> which means they are written to <code>true</code>&#8201;&#8212;&#8201;the number
of posts is not tracked. Each posting operation can touch any subset of the
notification bits, which means the post operation is effectively bitwise-OR-ing
a 32-bit mask into the task&#8217;s notification set (which is exactly how it&#8217;s
implemented).</p>
</div>
<div class="paragraph">
<p>Importantly, posting a notification does <em>not</em> interrupt the receiving task&#8217;s
code&#8201;&#8212;&#8201;it is not like a signal handler or asynchronous exception. Instead, the
receiving task finds out about the notifications only when it checks.</p>
</div>
<div class="paragraph">
<p>Tasks check for notifications by calling <code>recv</code>&#8201;&#8212;&#8201;the <code>recv</code> operation takes an
additional parameter called the <em>notification mask,</em> which is a 32-bit word. Any
1-bits in the notification mask express to the kernel that the task would like
to find out if the corresponding bit in its notification set has been posted
since it last checked.</p>
</div>
<div class="paragraph">
<p>If any of the requested bits have been posted:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The kernel atomically clears the bits that have been noticed (but leaves
others intact),</p>
</li>
<li>
<p>The task immediately returns from <code>recv</code> without blocking, and</p>
</li>
<li>
<p>The result of <code>recv</code> is a <em>notification message</em> instead of an IPC.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The task can distinguish a notification message from its contents:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The sender&#8217;s <code>TaskId</code> will be <code>TaskId::KERNEL</code>, indicating that the message
comes from the kernel. Since the kernel never sends messages in any other
context, any message &#8220;from&#8221; the kernel is a notification.</p>
</li>
<li>
<p>The <code>operation</code> field will contain the bits that were posted and matched the
provided mask. (These are also the bits that the kernel atomically cleared.)</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_what_are_they_good_for">3.5.1. What are they good for?</h4>
<div class="paragraph">
<p>Notifications are used by the kernel to route hardware interrupts to tasks: a
task can request that an interrupt appear as one of its notification bits. (More
on that in the chapter on Interrupts, below.)</p>
</div>
<div class="paragraph">
<p>Notifications are also used to signal tasks that the deadline they loaded into
their timer has elapsed. (More on that in the chapter on Timers.)</p>
</div>
<div class="paragraph">
<p>Finally, notifications can be valuable between tasks in an application, as a way
for one task to notify another of an event without blocking. In particular,
notifications are the only safe way for a high-priority server shared by many
clients to signal a single client&#8201;&#8212;&#8201;if it used <code>send</code> instead, that client
could decide not to <code>reply</code>, starving all the other clients.</p>
</div>
<div class="paragraph">
<p>In developing firmware on Hubris we&#8217;ve found a particular pattern to be useful,
called &#8220;pingback.&#8221; In this pattern, a high-priority shared server (such as a
network stack) has obtained data that it needs to give to one of its clients&#8201;&#8212;&#8201;but it can&#8217;t just <code>send</code> the data for the reason described above. One option is
to have all clients forever blocked in <code>send</code> to the <em>server</em> until data
arrived, but that keeps the clients from ever doing anything else! Instead, the
server and clients can agree on a protocol where</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The client <code>send</code>s to the server, to do whatever setup is required (e.g. to
express interest in data from a particular port). The client provides the server
with a <em>notification set</em> that it wants to receive when the event occurs.</p>
</li>
<li>
<p>The server notes this and <code>reply</code>s immediately.</p>
</li>
<li>
<p>The client goes on about its business, periodically checking for the
notifications it requested.</p>
</li>
<li>
<p>When the server receives data, it posts a notification to the client.</p>
</li>
<li>
<p>When the client notices this, it calls back to the server seeking more
information, and providing a writable lease to some memory where the server can
deposit the result.</p>
</li>
<li>
<p>The server receives this message and copies the data over.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This pattern is useful, in part, because it&#8217;s very tolerant of a defective
client task. If the server posts the notification and the client <em>never
responds,</em> it&#8217;s no skin off the server&#8217;s back&#8201;&#8212;&#8201;it&#8217;s still free to continue
serving other clients.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interrupts">4. Interrupts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter discusses the role of CPU interrupts in Hubris and applications.
We&#8217;ll be using some ARM-inspired terminology, because that&#8217;s the most mature
Hubris port, but these ideas are intended to translate to RISC-V systems using
controllers like the PLIC.</p>
</div>
<div class="sect2">
<h3 id="_interrupts_vs_exceptions">4.1. Interrupts vs Exceptions</h3>
<div class="paragraph">
<p>Hubris distinguishes between <strong>interrupts</strong> and <strong>exceptions</strong>. The terminology is
from ARM, but it&#8217;s a general idea that&#8217;s also valid on RISC-V.</p>
</div>
<div class="paragraph">
<p>An <em>interrupt</em> is generated by a peripheral to signal an asynchronous event.
Drivers usually want to find out about some set of interrupts and react to them.</p>
</div>
<div class="paragraph">
<p>An <em>exception</em> is a broader idea that includes signals generated by the
processor in response to the program&#8217;s behavior. This would include memory
access violations, illegal instructions, privilege violations, bus faults,
system calls, etc. Exceptions may be asynchronous but are often synchronous.</p>
</div>
<div class="paragraph">
<p>The kernel provides first-line handlers (interrupt service routines) for all
exceptions, interrupts included, but will also route <em>interrupts</em> to
applications.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_hubris_interrupt_model">4.2. The Hubris interrupt model</h3>
<div class="paragraph">
<p>We assume an interrupt system with the following characteristics. This is based
on the design of the ARMv6/7/8-M interrupt system, but is intended to be general.</p>
</div>
<div class="paragraph">
<p>You can likely skip this section if you&#8217;re not porting the kernel.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Interrupts can be numbered using small integers starting at zero. They may be
a subset of exception numbers at a fixed offset&#8201;&#8212;&#8201;16, on ARMvX-M&#8201;&#8212;&#8201;and we&#8217;ll
subtract that offset when numbering interrupts.</p>
</li>
<li>
<p>Interrupts have a &#8220;pending&#8221; flag and an &#8220;enable&#8221; flag. The pending flag
can be set by hardware at any time, but the ISR will only be invoked if the
enable and pending flags are set at the same time. (This ensures that
momentary events are latched and can be handled with a delay.) Starting the
interrupt service routine clears the &#8220;pending&#8221; flag and may or may not
affect the &#8220;enable&#8221; flag.</p>
</li>
<li>
<p>Interrupt handlers (or interrupt service routines) can be configured not to
preempt one another, either by configuring priorities in the interrupt
controller, or by using explicit critical sections in the implementation.
Hubris runs a quick generic ISR that records an interrupt and returns, so
nested interrupts are less important. If an interrupt arrives while an ISR is
running, it should remain pending until the current ISR returns. (This also
implies that interrupts cannot preempt the kernel, since the kernel always
runs in interrupt context.)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For brevity in the discussion below, we&#8217;ll refer to an interrupt &#8220;happening&#8221;
as when the CPU decides to execute the associated in-kernel interrupt service
routine. That can occur when&#8230;&#8203;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>pending</code> bit is set while <code>enable</code> was already set.</p>
</li>
<li>
<p>The <code>enable</code> bit is set when <code>pending</code> was previously set.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="interrupts-from-a-tasks-perspective">4.3. Interrupts from a task&#8217;s perspective</h3>
<div class="paragraph">
<p>The <code>app.toml</code> configuration file can route interrupts to tasks, by binding
platform interrupt numbers to <em>notification sets.</em> From the task&#8217;s perspective,
interrupts are delivered as notifications (see the IPC chapter).</p>
</div>
<div class="paragraph">
<p>Hubris does not allow a single interrupt to be routed to multiple tasks, which
means that a task has exclusive control over any interrupts it handles. Tasks
have access to a syscall, <a href="#sys_irq_control"><code>irq_control</code></a>, that they can use to mask and unmask
their interrupts.</p>
</div>
<div class="paragraph">
<p>When a task starts (or restarts) its interrupts are initially masked. This means
that the hardware <code>enable</code> bit is clear, and interrupts can accumulate in the
<code>pending</code> bit but will not translate to notifications.</p>
</div>
<div class="paragraph">
<p>The task can use <code>irq_control</code> to unmask (or mask) a subset of its interrupts.
When calling <code>irq_control</code>, the task names its interrupts by the notification
bits they will set when they fire, rather than their hardware interrupt numbers.
This means the task can be written to service multiple sources of interrupts
without code changes, only configuration changes. It also removes the need to
validate ownership of the interrupt in the kernel: since tasks can only specify
interrupts using their own notification masks, they can&#8217;t pick arbitrary IRQ
numbers that might be invalid or owned by someone else.</p>
</div>
<div class="paragraph">
<p>Once the interrupt is unmasked, <code>pending</code> will cause the kernel ISR to fire,
preempting some task code. The only things the ISR does are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Posts the requested notification to the handling task.</p>
</li>
<li>
<p>Masks the interrupt (clearing <code>enable</code>).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Once the handling task is waiting in <code>receive</code> with the interrupt&#8217;s notification
bit included in its notification mask, and is the highest priority task that&#8217;s
ready to go, it will be woken with a notification about the interrupt. It would
normally respond to this by inspecting the hardware to figure out the details of
the event and the next steps required, and then using <code>irq_control</code> to unmask
the interrupt again.</p>
</div>
<div class="paragraph">
<p>In simplified pseudocode, an interrupt handling task&#8217;s main loop looks something
like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="c1">// This task only uses notification bit 0 for interrupts.</span>
<span class="k">const</span> <span class="n">MY_INTERRUPT</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// We're willing to accept interrupts.</span>
<span class="nf">sys_irq_control</span><span class="p">(</span><span class="n">MY_INTERRUPT</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>

<span class="k">loop</span> <span class="p">{</span>

    <span class="c1">// Receive a message -- in this case, we're only</span>
    <span class="c1">// expecting notifications.</span>
    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">sys_recv_closed</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[],</span>
        <span class="n">MY_INTERRUPT</span><span class="p">,</span>
        <span class="nn">TaskId</span><span class="p">::</span><span class="n">KERNEL</span><span class="p">,</span>
    <span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">result</span><span class="py">.operation</span> <span class="o">&amp;</span> <span class="n">MY_INTERRUPT</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nf">do_interrupt_stuff</span><span class="p">();</span>
        <span class="c1">// Unmask that interrupt so it can fire again.</span>
        <span class="nf">sys_irq_control</span><span class="p">(</span><span class="n">MY_INTERRUPT</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_routing_interrupts_to_tasks_in_the_kernel">4.4. Routing interrupts to tasks in the kernel</h3>
<div class="paragraph">
<p>The kernel has a table of interrupt routing information, filled out at compile
time from the <code>app.toml</code>. For each implemented interrupt, it stores two pieces
of information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <em>index</em> of the task that will handle the interrupt.</p>
</li>
<li>
<p>The <em>notification set</em> that should be posted to that task when the interrupt
occurs.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Typically an SoC will have many interrupts that are not used by a given
application. We currently store interrupt response information only for the
interrupts that are being used, which makes looking up table entries slightly
slower in exchange for saving a bunch of Flash.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When an interrupt happens, it gets routed to a generic kernel ISR. The kernel
ISR will find the task named in the response record, and post the notification
set. The kernel then clears the interrupt&#8217;s <code>enable</code> bit to prevent reoccurrence
until the task has a chance to respond.</p>
</div>
<div class="paragraph">
<p>As with any situation where the kernel posts notifications, the kernel exit path
then checks to see if the notification has caused the scheduling situation to
change&#8201;&#8212;&#8201;in this case, if the task handling the interrupt is higher priority
than whatever task was running before, and is ready to receive it. If so, the
kernel saves context for the interrupted task and switches to the handler task.</p>
</div>
</div>
<div class="sect2">
<h3 id="_kernel_reserved_interrupts">4.5. Kernel reserved interrupts</h3>
<div class="paragraph">
<p>Some interrupts on some systems cannot be reasonably handled outside the kernel.
In these cases, the kernel will handle them directly, and provide abstractions
if necessary.</p>
</div>
<div class="paragraph">
<p>The main example here is the system tick timer that is used to maintain the
kernel&#8217;s internal sense of time, but DMA controllers might also fall into this
category.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="timers">5. Timers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In addition to fancier hardware timers, the microcontrollers we target tend to
have a single general-use timer that is portable across implementations and
silicon vendors&#8201;&#8212;&#8201;the <code>SysTick</code> on ARM, the <code>mtimer</code> on RISC-V. Hubris provides
a multiplexer for this timer, so that each task appears to have its own.</p>
</div>
<div class="paragraph">
<p>The time unit of the clock is selectable by the application, but in practice, we
always select milliseconds. This chapter will refer to the clock unit as
milliseconds.</p>
</div>
<div class="sect2">
<h3 id="_timestamp_format">5.1. Timestamp format</h3>
<div class="paragraph">
<p>Hubris timestamps are from a monotonic realtime clock. Time is kept since kernel
startup, which presumably corresponds to the most recent CPU reset or bootloader
exit. Without outside information (such as data from an external RTC) there&#8217;s no
way to map a Hubris timestamp to human wall time&#8201;&#8212;&#8201;they&#8217;re mostly used for
relative delays.</p>
</div>
<div class="paragraph">
<p>When interacting with the kernel, timestamps are expressed as milliseconds in
<code>u64</code> format. This means the timer will roll over after a bit more than 584
million years of continuous operation. The intent is that applications need not
concern themselves with timer wraparound, because reasoning about timer
wraparound is hard.</p>
</div>
<div class="paragraph">
<p>The kernel reserves the right to keep time in a different format internally.</p>
</div>
</div>
<div class="sect2">
<h3 id="_programmers_model">5.2. Programmer&#8217;s model</h3>
<div class="paragraph">
<p>Each task gets a timer. The timer has three properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An <em>enable bit.</em></p>
</li>
<li>
<p>A <em>deadline.</em></p>
</li>
<li>
<p>A <em>notification set.</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>At periodic intervals (ticks), if the enable bit is set, the kernel checks the
deadline to see if it is in the future. If not (it is <code>&lt;=</code> the current time),
the kernel will</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Clear the enable bit.</p>
</li>
<li>
<p>Post the notification set to the owning task. (Notifications are discussed in
more detail in <a href="#notifications">Notifications: the <em>other</em> IPC mechanism</a>.)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The task will find out about this next time it enters <code>recv</code> with the
notification bits unmasked&#8201;&#8212;&#8201;or immediately, if the task is already blocked in
<code>recv</code> at the time the timer fires.</p>
</div>
<div class="paragraph">
<p>Because the enable bit is cleared when the timer fires, tasks can assume that
setting their timer will result in exactly zero or one notification events.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If a task sets the timer notification set to <code>0</code>, it will not receive a
notification when the timer fires, but it could still poll the enable bit. We
haven&#8217;t had a use for this so far, but, now you know.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, when a task is initialized, its timer is set up as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Enable bit clear.</p>
</li>
<li>
<p>Deadline <code>!0</code> (i.e. the distant future)</p>
</li>
<li>
<p>Notification set <code>0</code> (i.e. no bits)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_timer_control_operations">5.3. Timer control operations</h3>
<div class="paragraph">
<p>Tasks access their timers through a pair of syscalls,
<a href="#sys_set_timer"><code>set_timer</code></a> and <a href="#sys_get_timer"><code>get_timer</code></a>. <code>get_timer</code> is
overloaded to return both the current kernel time and the contents of the task&#8217;s
timer&#8201;&#8212;&#8201;this is convenient because it ensures that both were observed at the
same (kernel) time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_the_timer_to_implement_sleep">5.4. Using the timer to implement <code>sleep</code></h3>
<div class="paragraph">
<p>The most common use of the task timer is to implement a delay. If this is <em>all</em>
you&#8217;re doing&#8201;&#8212;&#8201;i.e. you don&#8217;t have several deadlines to juggle&#8201;&#8212;&#8201;then it&#8217;s
fairly easy:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Choose a notification bit that isn&#8217;t used for other purposes.</p>
</li>
<li>
<p>Set the timer for the desired wake time.</p>
</li>
<li>
<p>Enter a <em>closed receive</em> from only the kernel&#8217;s TaskId, giving a notification
mask with only the chosen bit set.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>During this sleep, incoming messages will queue, and other notification bits
will accumulate, but the task will only wake when the deadline is reached.</p>
</div>
<div class="paragraph">
<p>The <code>userlib</code> crate provides an implementation of this using notification bit 31
in the <code>userlib::hl</code> module.</p>
</div>
</div>
<div class="sect2">
<h3 id="_multiplexing_your_multiplexed_timer">5.5. Multiplexing your multiplexed timer</h3>
<div class="paragraph">
<p>If a task needs to track multiple delays, it will need to maintain some
in-memory data structure (such as a table or heap) tracking their deadlines. At
any given time, the kernel-provided timer should be set to the <em>lowest</em>
deadline. When it fires, take action and then load the next lowest. And so
forth.</p>
</div>
<div class="paragraph">
<p>The <code>multitimer</code> crate implements such a multiplexed timer.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_startup">6. Startup</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This document describes how Hubris takes a CPU from reset to running your
application. It is mostly architecture-neutral; any architecture-specific bits
will be called out.</p>
</div>
<div class="sect2">
<h3 id="_from_reset_to_rust">6.1. From reset to Rust</h3>
<div class="paragraph">
<p>At reset, the processor runs a designated chunk of code, the <strong>reset handler.</strong>
Hubris&#8217;s reset handler is responsible for making the world safe for Rust code.
This means:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Setting up a stack pointer, if the hardware doesn&#8217;t do that for us;</p>
</li>
<li>
<p>Enabling any processor features or memory devices required to run the kernel&#8201;&#8212;&#8201;for example, if the device has an FPU, we need it turned on so we can
configure it even though the kernel itself may not use floating point;</p>
</li>
<li>
<p>Ensuring that all initialized variables get initialized;</p>
</li>
<li>
<p>Jumping to <code>main</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>On ARMv6-M, ARMv7-M, and ARMv8-M this sequence is handled by the <code>cortex_m_rt</code>
crate, which in turn uses the <code>r0</code> crate to set up Rust variables.</p>
</div>
</div>
<div class="sect2">
<h3 id="_main_bring_your_own">6.2. <code>main</code>: bring your own</h3>
<div class="paragraph">
<p>Currently, Hubris expects the application packager (i.e. you) to provide a
<code>main</code> routine in the crate that builds the kernel. This gives you an
opportunity to do any setup that isn&#8217;t handled by the runtime startup, but needs
to happen before the kernel boots.</p>
</div>
<div class="paragraph">
<p><code>main</code> should do those things, and then call <code>start_kernel</code>.</p>
</div>
<div class="paragraph">
<p>This same file is where you might declare interrupt service routines for any
SoC-specific interrupts that you wish to handle outside Hubris&#8217;s standard
mechanism&#8201;&#8212;&#8201;for cases where an interrupt is so latency-sensitive that you need
to handle it with a privileged ISR, despite the safety implications. Hubris&#8217;s
internal ISR symbols are weak, so, declaring an ISR in this file overrides them.</p>
</div>
</div>
<div class="sect2">
<h3 id="_starting_the_kernel">6.3. Starting the kernel</h3>
<div class="paragraph">
<p>The kernel expects to be packaged in Flash with a table describing the tasks.
This table is defined in <code>kconfig.rs</code>, which is generated at compile time
by the kernel&#8217;s <code>build.rs</code> and included at the bottom of
<code>sys/kern/src/startup.rs</code>.</p>
</div>
<div class="paragraph">
<p>The table consists of the following (all the types named here are defined in
the <code>abi</code> crate):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An <code>App</code> header record describing the overall shape of things to come.</p>
</li>
<li>
<p>One or more region descriptor (<code>RegionDesc</code>) records, carving up address
space into regions with attributes.</p>
</li>
<li>
<p>One or more task descriptor (<code>TaskDesc</code>) records describing tasks.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Region descriptors can technically be shared among tasks&#8201;&#8212;&#8201;task
descriptors specify the regions they can access by <em>index</em>. Task descriptors
contain the initial program counter and stack pointer values for the task,
which will be loaded into those registers when the task first runs (or is
restarted). Hubris will check that those pointers fall within some memory
region, but other than that, the layout of your task memory regions and their
roles is totally up to you. This means you <em>could</em> create an application with
tasks that share a Flash code region, for instance, though, think carefully
before doing so.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>start_kernel</code> reads the <code>App</code> header and the task and region descriptors,
validates their integrity, and initializes bookkeeping information for each
task described in the task table. This data is allocated in <code>static mut</code> arrays
<code>HUBRIS_TASK_TABLE_SPACE</code> and <code>HUBRIS_REGION_TABLE_SPACE</code>, which are declared
in the autogenerated <code>kconfig.rs</code>. The few kernel global variables are <strong>not</strong>
placed here; it&#8217;s only used for stuff that is sized based on information found
in the <code>app.toml</code> configuration.</p>
</div>
<div class="paragraph">
<p>Any extra RAM allocated to the kernel, but not used, is lost.</p>
</div>
</div>
<div class="sect2">
<h3 id="_starting_the_first_tasks">6.4. Starting the first task(s)</h3>
<div class="paragraph">
<p>One of the fields in the task descriptor contains a <code>START_AT_BOOT</code> flag. Any
task with this flag set will be initialized in <code>Runnable</code> state; all others are
initialized in <code>Stopped</code> state. (The <code>START_AT_BOOT</code> flag in the descriptor
corresponds to the <code>start = true</code> field in the <code>app.toml</code>.)</p>
</div>
<div class="paragraph">
<p>As its last act during startup, the kernel scans the tasks looking for the
<strong>highest priority</strong> task marked <code>START_AT_BOOT</code>. It then switches into that task,
and your application is running.</p>
</div>
<div class="paragraph">
<p>If the task descriptor table contains <strong>zero</strong> tasks marked <code>START_AT_BOOT</code>, this
represents an application configuration error, and the kernel will panic.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hubris_syscalls">7. Hubris Syscalls</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Syscalls provide ways for tasks to invoke kernel code. Hubris has a very small
set of syscalls, because syscalls&#8201;&#8212;&#8201;unlike IPC&#8201;&#8212;&#8201;have to be implemented in the
kernel and are hard to proxy, so they form an ongoing ABI commitment.</p>
</div>
<div class="paragraph">
<p>In general, the following sorts of things are syscalls (exhaustive):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>IPC primitives</p>
<div class="ulist">
<ul>
<li>
<p>Send, Receive, Reply</p>
</li>
<li>
<p>Access to memory borrowed from senders</p>
</li>
<li>
<p>Looking up the correct generation number for a task</p>
</li>
</ul>
</div>
</li>
<li>
<p>Access to the multiplexed per-task timer</p>
</li>
<li>
<p>Control of the current task&#8217;s interrupt mask</p>
</li>
<li>
<p>Crashing the current task</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And the following sorts of things are not (not exhaustive):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Checking the state or fault information of a task</p>
</li>
<li>
<p>Starting/restarting a task</p>
</li>
<li>
<p>Forcing faults on other tasks</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is because the things in the <em>first</em> category are universal, or nearly so,
while the things in the <em>second</em> category are normally used only in special
cases, usually by the supervisor task.</p>
</div>
<div class="paragraph">
<p>In general, syscalls should represent <strong>operations that every task should have
access to,</strong> while anything privileged or sensitive should be done through IPC.</p>
</div>
<div class="paragraph">
<p>This doesn&#8217;t mean all these things need to be done outside the kernel, though.
We have an escape hatch, in the form of messages to the virtual &#8220;kernel
task.&#8221; The kernel IPC interface is the topic of the next chapter.</p>
</div>
<div class="sect2">
<h3 id="_syscall_abi">7.1. Syscall ABI</h3>
<div class="paragraph">
<p>Syscalls are invoked using the architecture&#8217;s supervisor-call instruction or
equivalent.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll describe syscalls in an architecture-independent manner below by referring
to abstract <strong>argument and return slots</strong> instead of register names. Syscalls have
seven argument slots and eight return slots.</p>
</div>
<div class="paragraph">
<p>We assume that all registers are 32 bits wide.</p>
</div>
<div class="sect3">
<h4 id="_armv6_m_armv7_m_armv8_m">7.1.1. ARMv6-M / ARMv7-M / ARMv8-M</h4>
<div class="paragraph">
<p>Syscalls are invoked using the <code>SVC</code> instruction. The 8-bit immediate in the
instruction is ignored, because reading it from user text is potentially
sketchy.</p>
</div>
<div class="paragraph">
<p>Syscalls provide for up to 7 arguments and 8 return values in registers.
Syscalls never use arguments from the stack, to make it easier to reason about
possible memory management faults during syscall entry (i.e. now there aren&#8217;t
any).</p>
</div>
<div class="paragraph">
<p>Arguments to syscalls are passed in <code>r4</code> through <code>r10</code>, with the syscall index
in <code>r11</code>.</p>
</div>
<div class="paragraph">
<p>Return values from syscalls are returned in <code>r4</code> through <code>r11</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You&#8217;re probably wondering why we&#8217;re using weird registers instead of the
standard calling convention, which would pass things in <code>r0</code> through <code>r3</code>. It
comes back to the point above about stack accesses. The ARMvX-M hardware stores
<code>r0</code> through <code>r3</code> <em>on the user stack</em> on entry to a syscall, and we don&#8217;t want
to have to read it back from there. <code>r4</code> through <code>r11</code>, on the other hand, are
treated as callee-save, and our syscall entry sequence saves them into the TCB,
where we can refer to them as needed.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This calling convention is somewhat awkward on ARMv6-M, where the
registers above <code>r7</code> are second-class. So it goes.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_risc_v">7.1.2. RISC-V</h4>
<div class="paragraph">
<p>Syscalls are invoked using the <code>ECALL</code> instruction. The rest is TBD.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_syscalls">7.2. Syscalls</h3>
<div class="sect3">
<h4 id="sys_send">7.2.1. <code>SEND</code> (0)</h4>
<div class="paragraph">
<p>Sends a message.</p>
</div>
<div class="paragraph">
<p>The error-free path:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Identifies the desired recipient.</p>
</li>
<li>
<p>Transfers a message (0+ bytes) from an outgoing slice in your task&#8217;s memory,
into an incoming slice in the recipient&#8217;s memory.</p>
</li>
<li>
<p>Waits until the recipient calls <code>REPLY</code>.</p>
</li>
<li>
<p>During this time, allows the recipient to access your task&#8217;s memory, subject
to the rules laid out in the lease table.</p>
</li>
<li>
<p>Once <code>REPLY</code> happens, transfers the reply from the recipient&#8217;s memory into the
reply buffer slice in your task&#8217;s memory.</p>
</li>
<li>
<p>Resumes your task.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_arguments">Arguments</h5>
<div class="ulist">
<ul>
<li>
<p>0: packed target and operation.</p>
<div class="ulist">
<ul>
<li>
<p>Bits 31:16: target task ID (split into index and generation per the constants
in the <code>abi</code> crate).</p>
</li>
<li>
<p>Bits 15:0: operation code (application defined).</p>
</li>
</ul>
</div>
</li>
<li>
<p>1: Base address of outgoing message.</p>
</li>
<li>
<p>2: Length of outgoing message, in bytes.</p>
</li>
<li>
<p>3: Base address of buffer where a reply should be deposited.</p>
</li>
<li>
<p>4: Size of reply buffer, in bytes.</p>
</li>
<li>
<p>5: Base address of lease table.</p>
</li>
<li>
<p>6: Number of leases in lease table.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_lease_table_layout">Lease table layout</h5>
<div class="paragraph">
<p>Each lease is 12 bytes in size and must be 4-byte aligned. A lease is equivalent
to the following Rust struct:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="nd">#[repr(C)]</span>
<span class="k">struct</span> <span class="n">Lease</span> <span class="p">{</span>
    <span class="n">attributes</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">base_address</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">length</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">ATT_READ</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="n">ATT_WRITE</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>attributes</code> can specify that a lease can be read from, written to, or both.
Any use of undefined attribute bits will cause a fault.</p>
</li>
<li>
<p><code>base_address</code> is a byte-aligned address. If this points to memory your task
can&#8217;t access, it will cause a fault.</p>
</li>
<li>
<p><code>length</code> is the length of the leased memory region in bytes.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_return_values">Return values</h5>
<div class="ulist">
<ul>
<li>
<p>0: response code (application defined with caveat below).</p>
</li>
<li>
<p>1: length of reply deposited into reply buffer.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_faults">Faults</h5>
<div class="paragraph">
<p>Most things that can go wrong with <code>SEND</code> are programming errors, and will cause
your task to be immediately faulted instead of returning a code.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Condition</th>
<th class="tableblock halign-left valign-top">Fault taken</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recipient forbidden by your task&#8217;s (static) IPC mask.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BadInteraction</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recipient task index greater than the (static) number of tasks in the entire
  system.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TaskOutOfRange</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any slice invalid (e.g. it would wrap the end of the address space).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InvalidSlice</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lease table slice misaligned.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InvalidSlice</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Outgoing slice or lease table are memory you can&#8217;t actually read.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MemoryAccess</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reply buffer slice is memory you can&#8217;t actually write.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MemoryAccess</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_notes">Notes</h5>
<div class="paragraph">
<p>Target and operation are packed into a single word because we&#8217;re out of useful
registers on ARM. This currently limits operation codes to 16 bits. We might
revisit this later.</p>
</div>
<div class="paragraph">
<p>For all slices (outgoing message, reply buffer, lease table), if the count is
zero, the base address won&#8217;t be dereferenced and can be illegal. In particular,
it&#8217;s okay to pass address 0 for empty slices.</p>
</div>
<div class="paragraph">
<p>If the slices are <strong>not</strong> zero length, however, the kernel will check them against
your task&#8217;s memory map, and your task will be faulted if anything is amiss.</p>
</div>
<div class="paragraph">
<p>Slices are accessed by the kernel <strong>only</strong> while your task is blocked in <code>SEND</code>,
so passing a slice to the kernel here can be done safely (in the Rust sense).
The reply buffer slice must be an <code>&amp;mut</code>, but the others can be <code>&amp;</code>.</p>
</div>
<div class="paragraph">
<p>The lease table slice must be 4-byte aligned. The others can be arbitrarily
aligned.</p>
</div>
<div class="paragraph">
<p>Response codes are application defined except for one subtlety: <strong>dead codes.</strong>
The kernel will deliver a dead code in two situations:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>SEND to a task with the wrong generation, suggesting that the recipient has
restarted without the sender noticing.</p>
</li>
<li>
<p>If the recipient crashes while the sender is waiting&#8201;&#8212;&#8201;either waiting to
transfer the initial message, or waiting for the reply.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Dead codes have their top 24 bits set (that is, <code>0xFFFF_FF00</code>). In the bottom 8
bits, the kernel returns the <em>current</em> generation number of the peer, so that
the caller can correct their records.</p>
</div>
<div class="paragraph">
<p>It is possible to fake a dead task by deliberately sending a response code in
the dead code range&#8201;&#8212;&#8201;because it didn&#8217;t seem useful to spend cycles filtering
this out.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sys_recv">7.2.2. <code>RECV</code> (1)</h4>
<div class="paragraph">
<p>Receives a pending message or notification.</p>
</div>
<div class="paragraph">
<p>The error-free path:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Blocks until some number of tasks are ready to send to your task.</p>
</li>
<li>
<p>Picks the highest priority one.</p>
</li>
<li>
<p>Transfers its message into memory you&#8217;ve designated.</p>
</li>
<li>
<p>Keeps the sending task blocked.</p>
</li>
<li>
<p>Returns information describing the message to your task.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the provided notification mask is not zero, the receive operation may be
interrupted by a <em>notification message</em> from the kernel instead. This happens
if any of the notification bits specified in the mask (by 1 bits) have been set
on the calling task. When RECV returns, you can distinguish these notification
messages because they have the kernel&#8217;s virtual task ID <code>0xFFFF</code> as the message
sender.</p>
</div>
<div class="sect4">
<h5 id="_closed_vs_open_recv">Closed vs Open RECV</h5>
<div class="paragraph">
<p>One argument to RECV determines whether to accept messages from <em>any</em> sender, or
to only accept messages from <em>one.</em> Accepting messages from any sender is called
an &#8220;open&#8221; receive, while only listening for one sender is &#8220;closed.&#8221;</p>
</div>
<div class="paragraph">
<p>During an open receive, a task may receive messages sent by any other task, plus
any notifications enabled by the notification mask.</p>
</div>
<div class="paragraph">
<p>During a closed receive, a task will receive messages only from the chosen task.
The task will still receive any notifications set in its notification mask.</p>
</div>
<div class="paragraph">
<p>To listen <strong>only</strong> for notifications, a task can perform a closed receive against
the kernel&#8217;s task ID, <code>0xFFFF</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_arguments_2">Arguments</h5>
<div class="ulist">
<ul>
<li>
<p>0: Address of a buffer where received messages should be written.</p>
</li>
<li>
<p>1: Number of bytes in that buffer.</p>
</li>
<li>
<p>2: Notification mask to apply during this receive.</p>
</li>
<li>
<p>3: Sender filter for open vs closed receive.</p>
<div class="ulist">
<ul>
<li>
<p>Bit 31: 0=open, 1=closed</p>
</li>
<li>
<p>Bits 30:16: reserved</p>
</li>
<li>
<p>Bits 15:0: TaskId if closed, ignored if open.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_return_values_2">Return values</h5>
<div class="ulist">
<ul>
<li>
<p>0: always 0 for open receive; closed receive may also return a <strong>dead code</strong>
(see <code>SEND</code>) to indicate that the chosen peer has died.</p>
</li>
<li>
<p>1: Task ID of the sender (generation in 15:12, ID in 11:0).</p>
</li>
<li>
<p>2: Operation code used by sender. (Or notification bits, if the sender is the
kernel.)</p>
</li>
<li>
<p>3: Length of message sent, in bytes. This may be longer than the buffer
provided by the caller, which indicates that the message was truncated.</p>
</li>
<li>
<p>4: Number of bytes of room the caller has provided for the reply message.</p>
</li>
<li>
<p>5: Number of leases provided with message.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_faults_2">Faults</h5>
<div class="paragraph">
<p>Most things that can go wrong with <code>RECV</code> are programming errors, and will cause
your task to be immediately faulted instead of returning a code.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Condition</th>
<th class="tableblock halign-left valign-top">Fault taken</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Receive buffer slice invalid (i.e. would wrap the end of the address space).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InvalidSlice</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Receive buffer slice is memory you can&#8217;t actually write.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MemoryAccess</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_notes_2">Notes</h5>
<div class="paragraph">
<p>It&#8217;s legal to specify a zero-length receive buffer, if the messages you&#8217;re
expecting consist only of the operation code or notification bits. In this
case, the base address is ignored and may be invalid or null.</p>
</div>
<div class="paragraph">
<p>If the sender sent a message <em>longer</em> than your receive buffer, you will get the
<em>prefix</em> of the message, and the returned response length will give the <em>actual</em>
length. This means you should check the response length against your buffer
length to detect truncation.</p>
</div>
<div class="paragraph">
<p>Leases received with the message are referenced with the combination (TaskID,
lease number). Lease numbers range between 0 and one less than the received
lease count, as you&#8217;d expect. Leases are only valid until the sending task
unblocks, which normally happens only when you <code>REPLY</code>, but could also occur as
a result of an asynchronous restart from the supervisor.</p>
</div>
<div class="paragraph">
<p>The notification mask is provided anew with each receive because the <code>RECV</code>
callsite has a clear idea of which notifications it can handle. Plus, it saves a
syscall during the common pattern of updating the mask and then receiving.</p>
</div>
<div class="paragraph">
<p><code>RECV</code> is called <code>RECV</code> because Cliff can&#8217;t spell &#8220;recieve&#8221; reliably.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sys_reply">7.2.3. <code>REPLY</code> (2)</h4>
<div class="paragraph">
<p>Replies to a received message.</p>
</div>
<div class="paragraph">
<p>If all goes well, this copies a slice of data from your task&#8217;s memory into the
caller&#8217;s memory and resumes the caller.</p>
</div>
<div class="sect4">
<h5 id="_arguments_3">Arguments</h5>
<div class="ulist">
<ul>
<li>
<p>0: Task ID of sender we&#8217;re replying to.</p>
</li>
<li>
<p>1: Response code to deliver.</p>
</li>
<li>
<p>2: Base address of reply message.</p>
</li>
<li>
<p>3: Number of bytes in reply message.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_return_values_3">Return values</h5>
<div class="paragraph">
<p><code>REPLY</code> doesn&#8217;t return anything, but should be treated as clobbering return
registers 0 and 1 for future compatibility.</p>
</div>
</div>
<div class="sect4">
<h5 id="_faults_3">Faults</h5>
<div class="paragraph">
<p>There is only one way to break <code>REPLY</code>, and that&#8217;s with a bogus slice.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Condition</th>
<th class="tableblock halign-left valign-top">Fault taken</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Outgoing buffer slice invalid (i.e. would wrap the end of the address space).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InvalidSlice</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Outgoing buffer slice is memory you can&#8217;t actually read.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MemoryAccess</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reply message is longer than recipient requested.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ReplyTooBig</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_notes_3">Notes</h5>
<div class="paragraph">
<p>It might strike you as odd that <code>REPLY</code> doesn&#8217;t return any status. This is a
subtle decision, and has to do with what servers will do if their clients
&#8220;defect&#8221; or crash before reply (generally: nothing).</p>
</div>
<div class="paragraph">
<p>Reply messages can be zero-length, in which case the base address of the slice
is ignored. Often, the response code is enough.</p>
</div>
<div class="paragraph">
<p><code>RECV</code> delivers the size of the caller&#8217;s response buffer, so your task has
sufficient information to not overflow it. If the caller&#8217;s response buffer is
too small, you are expected to instead use <code>REPLY_FAULT</code> with the
<code>ReplyBufferTooSmall</code> code. If you instead send a reply that won&#8217;t fit, that&#8217;s
treated as a programming error in your task, and you take a <code>ReplyTooBig</code> fault.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sys_set_timer">7.2.4. <code>SET_TIMER</code> (3)</h4>
<div class="paragraph">
<p>Configures your task&#8217;s timer.</p>
</div>
<div class="sect4">
<h5 id="_arguments_4">Arguments</h5>
<div class="ulist">
<ul>
<li>
<p>0: Enable (1) or disable (0) flag.</p>
</li>
<li>
<p>1: Low 32 bits of deadline.</p>
</li>
<li>
<p>2: High 32 bits of deadline.</p>
</li>
<li>
<p>3: Notification bitmask to post when timer expires.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_return_values_4">Return values</h5>
<div class="paragraph">
<p>None. All registers preserved.</p>
</div>
</div>
<div class="sect4">
<h5 id="_faults_4">Faults</h5>
<div class="paragraph">
<p>None.</p>
</div>
</div>
<div class="sect4">
<h5 id="_notes_4">Notes</h5>
<div class="paragraph">
<p>The notification bitmask will be delivered into your task&#8217;s notification set
when the kernel time becomes equal to or greater than the given deadline, if the
timer is enabled. Configuring the timer with an enabled deadline that is already
in the past delivers the notification immediately (though you won&#8217;t notice until
you <code>RECV</code>).</p>
</div>
<div class="paragraph">
<p>The time unit for deadlines is not currently specified&#8201;&#8212;&#8201;it&#8217;s currently an
abstract &#8220;kernel ticks&#8221; unit. This will be fixed.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sys_borrow_read">7.2.5. <code>BORROW_READ</code> (4)</h4>
<div class="paragraph">
<p>Copies data from memory borrowed from a caller (a &#8220;borrow&#8221;).</p>
</div>
<div class="sect4">
<h5 id="_arguments_5">Arguments</h5>
<div class="ulist">
<ul>
<li>
<p>0: TaskId of lender.</p>
</li>
<li>
<p>1: Lease index for that lender.</p>
</li>
<li>
<p>2: Offset within the borrowed memory to start reading.</p>
</li>
<li>
<p>3: Base address of slice in your memory space to deposit data.</p>
</li>
<li>
<p>4: Length of slice in bytes.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_return_values_5">Return values</h5>
<div class="ulist">
<ul>
<li>
<p>0: response code: zero on success, non-zero if something went wrong on the
sender side.</p>
</li>
<li>
<p>1: on success, number of bytes copied.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_faults_5">Faults</h5>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect4">
<h5 id="_notes_5">Notes</h5>
<div class="paragraph">
<p>This provides &#8220;file-like&#8221; access to memory borrowed from other tasks, rather
than direct memory-mapped access, and that&#8217;s for a good reason: the other task
may potentially be restarted at any time. In the event that the peer restarts
while you&#8217;re working with one of its borrows, you&#8217;ll get an error return code
and can clean up&#8201;&#8212;&#8201;whereas if you were directly accessing its memory, we&#8217;d
have no choice but to deliver a fault to stop you. That would give clients the
opportunity to induce faults in shared servers, which would be bad.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sys_borrow_write">7.2.6. <code>BORROW_WRITE</code> (5)</h4>
<div class="paragraph">
<p>Copies data into memory borrowed from a caller (a &#8220;borrow&#8221;).</p>
</div>
<div class="sect4">
<h5 id="_arguments_6">Arguments</h5>
<div class="ulist">
<ul>
<li>
<p>0: TaskId of lender.</p>
</li>
<li>
<p>1: Lease index for that lender.</p>
</li>
<li>
<p>2: Offset within the borrowed memory to start writing.</p>
</li>
<li>
<p>3: Base address of data (in your memory space) to transfer.</p>
</li>
<li>
<p>4: Length of data in bytes.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_return_values_6">Return values</h5>
<div class="ulist">
<ul>
<li>
<p>0: response code: zero on success, non-zero if something went wrong on the
sender side.</p>
</li>
<li>
<p>1: on success, number of bytes copied.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_faults_6">Faults</h5>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect4">
<h5 id="_notes_6">Notes</h5>
<div class="paragraph">
<p>This provides &#8220;file-like&#8221; access to memory borrowed from other tasks, rather
than direct memory-mapped access, and that&#8217;s for a good reason: the other task
may potentially be restarted at any time. In the event that the peer restarts
while you&#8217;re working with one of its borrows, you&#8217;ll get an error return code
and can clean up&#8201;&#8212;&#8201;whereas if you were directly accessing its memory, we&#8217;d
have no choice but to deliver a fault to stop you. That would give clients the
opportunity to induce faults in shared servers, which would be bad.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sys_borrow_info">7.2.7. <code>BORROW_INFO</code> (6)</h4>
<div class="paragraph">
<p>Collects information about one entry in a sender&#8217;s lease table.</p>
</div>
<div class="sect4">
<h5 id="_arguments_7">Arguments</h5>
<div class="ulist">
<ul>
<li>
<p>0: TaskId of lender.</p>
</li>
<li>
<p>1: Lease index for that lender.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_return_values_7">Return values</h5>
<div class="ulist">
<ul>
<li>
<p>0: response code: zero on success, non-zero if something went wrong on the
sender side.</p>
</li>
<li>
<p>1: attributes field (see <code>SEND</code> for definition of lease table attributes).</p>
</li>
<li>
<p>2: length in bytes</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sys_irq_control">7.2.8. <code>IRQ_CONTROL</code> (7)</h4>
<div class="sect4">
<h5 id="_arguments_8">Arguments</h5>
<div class="ulist">
<ul>
<li>
<p>0: notification bitmask corresponding to the interrupt</p>
</li>
<li>
<p>1: desired state</p>
<div class="ulist">
<ul>
<li>
<p>bit 0: 0 = disabled, 1 = enabled</p>
</li>
<li>
<p>bit 1: 0 = leave pending, 1 = clear pending</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_return_values_8">Return values</h5>
<div class="paragraph">
<p>None.</p>
</div>
</div>
<div class="sect4">
<h5 id="_faults_7">Faults</h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Condition</th>
<th class="tableblock halign-left valign-top">Fault taken</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">The given notification bitmask is not mapped to an interrupt in this task.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NoIrq</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_notes_7">Notes</h5>
<div class="paragraph">
<p>It might seem strange that this syscall has tasks refer to interrupts using
their notification bits. However, this is quite deliberate, for two reasons:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It gives tasks a consistent semantic model. When an interrupt goes off, they
see a notification in bit X; when they want to re-enable that interrupt,
they request enabling on bit X. There is no separate &#8220;IRQ number&#8221; to
configure; that&#8217;s left to the application-level config file.</p>
</li>
<li>
<p>It makes it impossible for a task to mess with other tasks' interrupts,
since it can only refer to its <em>own</em> mapped interrupts, by construction.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The concept of a "pending" interrupt is inherently specific to a particular
architecture and interrupt controller. On an architecture without a concept of
pending interrupts, bit 1 has no effect. However, on architectures with
level-triggered interrupts from peripherals and a concept of "pending"
interrupts, clearing the pending status when re-enabling may be important for
avoiding a duplicate notification.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_panic_8">7.2.9. <code>PANIC</code> (8)</h4>
<div class="paragraph">
<p>Delivers a <code>Panic</code> fault to the calling task, recording an optional message.</p>
</div>
<div class="paragraph">
<p>This is roughly equivalent to the Rust <code>panic!</code> operation and is used in its
implementation.</p>
</div>
<div class="sect4">
<h5 id="_arguments_9">Arguments</h5>
<div class="ulist">
<ul>
<li>
<p>0: base address of 7-bit ASCII panic message</p>
</li>
<li>
<p>1: length of panic message in bytes</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_return_values_9">Return values</h5>
<div class="paragraph">
<p>Does not return.</p>
</div>
</div>
<div class="sect4">
<h5 id="_faults_8">Faults</h5>
<div class="paragraph">
<p>This produces a <code>Panic</code> fault every time&#8201;&#8212;&#8201;that&#8217;s its purpose.</p>
</div>
</div>
<div class="sect4">
<h5 id="_notes_8">Notes</h5>
<div class="paragraph">
<p>The kernel does not interpret the panic message in any way, but may be made
available to the supervisor if it asks.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sys_get_timer">7.2.10. <code>GET_TIMER</code> (9)</h4>
<div class="paragraph">
<p>Reads the contents of the task&#8217;s timer: both the current time, and any
configured deadline.</p>
</div>
<div class="sect4">
<h5 id="_arguments_10">Arguments</h5>
<div class="paragraph">
<p>None.</p>
</div>
</div>
<div class="sect4">
<h5 id="_return_values_10">Return values</h5>
<div class="ulist">
<ul>
<li>
<p>0: low 32 bits of kernel timestamp.</p>
</li>
<li>
<p>1: high 32 bits of kernel timestamp.</p>
</li>
<li>
<p>2: 0=no deadline set, 1=deadline set.</p>
</li>
<li>
<p>3: low 32 bits of deadline, if set.</p>
</li>
<li>
<p>4: high 32 bits of deadline, if set.</p>
</li>
<li>
<p>5: notifications to post when deadline reached.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_faults_9">Faults</h5>
<div class="paragraph">
<p>None.</p>
</div>
</div>
<div class="sect4">
<h5 id="_notes_9">Notes</h5>
<div class="paragraph">
<p>The timestamp is defined as being CPU-wide, consistent for all tasks, so the
result of this syscall can be meaningfully sent to other tasks on the same CPU.
(Behavior in multicore situations is not yet defined.)</p>
</div>
<div class="paragraph">
<p>The time unit is not currently specified&#8201;&#8212;&#8201;it&#8217;s currently an abstract &#8220;kernel
ticks&#8221; unit. This will be fixed.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_refresh_task_id_10">7.2.11. <code>REFRESH_TASK_ID</code> (10)</h4>
<div class="paragraph">
<p>Given a task ID that may have the wrong generation, produces a corrected task
ID with the target task&#8217;s current generation.</p>
</div>
<div class="paragraph">
<p>This is intended for two use cases:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Initially contacting a task. In this case, the generation can be arbitrary
and is usually given as zero.</p>
</li>
<li>
<p>Recovering from a peer task crashing. In this case, hand in your previously
valid TaskId to redeem it for a new one.</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="_arguments_11">Arguments</h5>
<div class="ulist">
<ul>
<li>
<p>0: task ID (in low 16 bits)</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_return_values_11">Return values</h5>
<div class="ulist">
<ul>
<li>
<p>0: task ID (in low 16 bits), top 16 bits zeroed</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_faults_10">Faults</h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Condition</th>
<th class="tableblock halign-left valign-top">Fault taken</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recipient task index greater than the (static) number of tasks in the entire
  system.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TaskOutOfRange</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_post_11">7.2.12. <code>POST</code> (11)</h4>
<div class="paragraph">
<p>Accumulates a set of notification bits into another task&#8217;s notification word
using bitwise OR. This enables a simple inter-task asynchronous communication
mechanism. See <a href="#notifications">Notifications: the <em>other</em> IPC mechanism</a> for more information on the mechanism.</p>
</div>
<div class="sect4">
<h5 id="_arguments_12">Arguments</h5>
<div class="ulist">
<ul>
<li>
<p>0: task ID (in low 16 bits)</p>
</li>
<li>
<p>1: bits to OR in</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_return_values_12">Return values</h5>
<div class="ulist">
<ul>
<li>
<p>0: zero on success, dead code on generation mismatch.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_faults_11">Faults</h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Condition</th>
<th class="tableblock halign-left valign-top">Fault taken</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recipient task index greater than the (static) number of tasks in the entire
  system.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TaskOutOfRange</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_notes_10">Notes</h5>
<div class="paragraph">
<p>If the task generation is wrong, the caller will receive a dead code (see
<a href="#death">Death and IPC</a>) and no notification will be posted.</p>
</div>
<div class="paragraph">
<p>If the task being notified is higher priority, and the notification causes it
to wake, control will immediately transfer to the higher priority task. This
will be returned as &#8220;success&#8221; to the caller, because the notification was
successfully delivered, even if the higher priority task subsequently crashes
before the caller gets another chance to run.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_reply_fault_12">7.2.13. <code>REPLY_FAULT</code> (12)</h4>
<div class="paragraph">
<p>Like <code>REPLY</code>, this resumes a task that is blocked waiting for a reply from the
invoking task. Unlike <code>REPLY</code>, this does not set the task runnable, and instead
marks it as faulted by a recognizable code.</p>
</div>
<div class="sect4">
<h5 id="_arguments_13">Arguments</h5>
<div class="ulist">
<ul>
<li>
<p>0: task ID (in low 16 bits)</p>
</li>
<li>
<p>1: <code>ReplyFaultReason</code> value (see <code>abi</code> crate)</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_return_values_13">Return values</h5>
<div class="paragraph">
<p><code>REPLY_FAULT</code> doesn&#8217;t return anything, but should be treated as clobbering
return registers 0 and 1 for future compatibility.</p>
</div>
</div>
<div class="sect4">
<h5 id="_faults_12">Faults</h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Condition</th>
<th class="tableblock halign-left valign-top">Fault taken</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Designated task index greater than the (static) number of tasks in the entire
  system.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TaskOutOfRange</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ReplyFaultReason</code> value undefined in <code>abi</code> enum.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BadReplyFaultReason</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_notes_11">Notes</h5>
<div class="paragraph">
<p>Like <code>REPLY</code>, this syscall just silently ignores replies to the wrong
generation, under the assumption that the task got restarted for some reason
while we were processing its request. (It can happen.)</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sys_irq_status">7.2.14. <code>IRQ_STATUS</code> (13)</h4>
<div class="paragraph">
<p>Returns the current status of interrupts mapped to the calling task.</p>
</div>
<div class="sect4">
<h5 id="_arguments_14">Arguments</h5>
<div class="ulist">
<ul>
<li>
<p>0: notification bitmask corresponding to the interrupt(s) to query</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_return_values_14">Return values</h5>
<div class="ulist">
<ul>
<li>
<p>0: an <code>IrqStatus</code> (see the <code>abi</code> crate) describing the status of the
interrupts in the notification mask. Currently, the following bits in
<code>IrqStatus</code> are significant:</p>
<div class="ulist">
<ul>
<li>
<p><code>0b0001</code>: set if any interrupt in the mask is enabled</p>
</li>
<li>
<p><code>0b0010</code>: set if an IRQ is pending for any interrupt in the mask</p>
</li>
<li>
<p><code>0b0100</code>: set if a notification has been posted to the caller but
not yet consumed</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_faults_13">Faults</h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Condition</th>
<th class="tableblock halign-left valign-top">Fault taken</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">The given notification bitmask is not mapped to an interrupt in this task.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NoIrq</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_notes_12">Notes</h5>
<div class="paragraph">
<p>As discussed in the notes for the <a href="#sys_irq_control">IRQ_CONTROL</a> syscall,
tasks refer to interrupts using their notification bits.</p>
</div>
<div class="paragraph">
<p>If the provided notification mask is zero, the syscall will return a <code>NoIrq</code>
fault. If the provided notification mask has multiple bits set, the returned
<code>IrqStatus</code> value will be the boolean OR of the status of all interrupts in the
map (e.g. if any interrupt in the mask is pending, the <code>PENDING</code> bit will be
set, and so on).</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_kernel_ipc_interface">8. The Kernel IPC Interface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hubris provides syscalls for operations that are used by every (or nearly
every) task, and uses IPC for everything else. But IPC is used to talk between
tasks&#8201;&#8212;&#8201;what about operations that require the kernel to be involved?</p>
</div>
<div class="paragraph">
<p>We still use IPC, we just do it with the kernel.</p>
</div>
<div class="paragraph">
<p>Hubris has a concept called the <strong>virtual kernel task</strong>. The virtual kernel
task is not a real task&#8201;&#8212;&#8201;it&#8217;s an illusion created by the kernel. Any messages
sent to the virtual kernel task will be processed in the kernel itself and
replied to directly.</p>
</div>
<div class="paragraph">
<p>The kernel answers to the task ID <code>TaskId::KERNEL</code> in Rust, which has the
numeric value <code>0xFFFF</code>. We chose this number so that the task index portion of
it (in the 10-12 LSBs) would be larger than any valid task index, so there&#8217;s no
risk of it colliding with an actual task.</p>
</div>
<div class="sect2">
<h3 id="_sending_messages_to_the_kernel">8.1. Sending messages to the kernel</h3>
<div class="paragraph">
<p>The kernel accepts normal IPC messages sent to <code>TaskId::KERNEL</code>. Currently, none
of the messages accepted by the kernel make use of leases/borrows, but that&#8217;s
just because they haven&#8217;t been useful yet.</p>
</div>
<div class="paragraph">
<p>The kernel makes a special guarantee: it will respond to IPCs synchronously,
without blocking the sender. This means it is safe to send IPCs to the kernel
from even the highest-priority tasks&#8201;&#8212;&#8201;in fact, for the <em>highest</em> priority task
(normally the supervisor), the kernel is the <em>only</em> place it can send messages
safely.</p>
</div>
<div class="paragraph">
<p>The kernel does not reply to <em>all</em> messages, however. Like making a bogus
syscall, if you send a message to the kernel that uses an out of range selector
or has a very malformatted body, the kernel will deliver a fault to your task
and move on to the next highest priority runnable code.</p>
</div>
<div class="paragraph">
<p>Messages sent to the kernel, and responses sent back, are formatted using the
<code>ssmarshal</code> crate via <code>serde</code>. Messages and responses are currently defined as
Rust structs, simply because we haven&#8217;t had a need to write a supervisor task in
C so far. We may wish to formalize this later, but, this is expedient for now.
Remember when reading the request/response types that it is the <code>ssmarshal</code>
serialized form, and not the in-memory layout of the struct, that is exchanged
with the kernel.</p>
</div>
<div class="paragraph">
<p>The <code>userlib::kipc</code> module provides wrapper functions for these IPCs for
programs written in Rust.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is our intent to restrict kernel IPC sends to &#8220;privileged&#8221; tasks&#8201;&#8212;&#8201;likely just the supervisor task. We haven&#8217;t implemented this yet for every
entry point, though some IPC entry points explicitly limit themselves
to the supervisor.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_read_task_status_1">8.1.1. <code>read_task_status</code> (1)</h4>
<div class="paragraph">
<p>Reads out status information about a task, <em>by index.</em> This is intended to be
used for task management purposes by the supervisor&#8201;&#8212;&#8201;because tasks can restart
whenever, the supervisor generally doesn&#8217;t want to concern itself with getting
generation numbers right.</p>
</div>
<div class="sect4">
<h5 id="_request">Request</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">struct</span> <span class="n">TaskStatusRequest</span> <span class="p">{</span>
    <span class="n">task_index</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_preconditions">Preconditions</h5>
<div class="paragraph">
<p>The <code>task_index</code> must be a valid index for this system.</p>
</div>
</div>
<div class="sect4">
<h5 id="_response">Response</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">type</span> <span class="n">TaskStatusResponse</span> <span class="o">=</span> <span class="nn">abi</span><span class="p">::</span><span class="n">TaskState</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_notes_13">Notes</h5>
<div class="paragraph">
<p>See the <code>abi</code> crate for the definition of <code>TaskState</code> that matches your kernel.
Here is a representative example at the time of this writing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">pub</span> <span class="k">enum</span> <span class="n">TaskState</span> <span class="p">{</span>
    <span class="cd">/// Task is healthy and can be scheduled subject to the `SchedState`</span>
    <span class="cd">/// requirements.</span>
    <span class="nf">Healthy</span><span class="p">(</span><span class="n">SchedState</span><span class="p">),</span>
    <span class="cd">/// Task has been stopped by a fault and must not be scheduled without</span>
    <span class="cd">/// intervention.</span>
    <span class="n">Faulted</span> <span class="p">{</span>
        <span class="cd">/// Information about the fault.</span>
        <span class="n">fault</span><span class="p">:</span> <span class="n">FaultInfo</span><span class="p">,</span>
        <span class="cd">/// Record of the previous healthy state at the time the fault was</span>
        <span class="cd">/// taken.</span>
        <span class="n">original_state</span><span class="p">:</span> <span class="n">SchedState</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">enum</span> <span class="n">FaultInfo</span> <span class="p">{</span>
    <span class="n">StackOverflow</span> <span class="p">{</span> <span class="n">address</span><span class="p">:</span> <span class="nb">u32</span> <span class="p">},</span>
    <span class="c1">// other fault cases go here</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">enum</span> <span class="n">SchedState</span> <span class="p">{</span>
    <span class="cd">/// This task is ignored for scheduling purposes.</span>
    <span class="n">Stopped</span><span class="p">,</span>
    <span class="cd">/// This task could be scheduled on the CPU.</span>
    <span class="n">Runnable</span><span class="p">,</span>
    <span class="cd">/// This task is blocked waiting to deliver a message to the given task.</span>
    <span class="nf">InSend</span><span class="p">(</span><span class="n">TaskId</span><span class="p">),</span>
    <span class="cd">/// This task is blocked waiting for a reply from the given task.</span>
    <span class="nf">InReply</span><span class="p">(</span><span class="n">TaskId</span><span class="p">),</span>
    <span class="cd">/// This task is blocked waiting for messages, either from any source</span>
    <span class="cd">/// (`None`) or from a particular sender only.</span>
    <span class="nf">InRecv</span><span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">TaskId</span><span class="o">&gt;</span><span class="p">),</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_reinit_task_2">8.1.2. <code>reinit_task</code> (2)</h4>
<div class="paragraph">
<p>Reinitializes a task, chosen by index, and optionally starts it running.</p>
</div>
<div class="paragraph">
<p>This is valid in any task state, and can be used to interrupt otherwise
uninterruptible operations like the SEND syscall.</p>
</div>
<div class="paragraph">
<p>A successful call to <code>reinit_task</code> has the following effects:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The targeted task is forced out of whatever state it was in, and left in
either the <code>Stopped</code> (if <code>start</code> is <code>false</code>) or <code>Runnable</code> (if <code>start</code> is
<code>true</code>) state.</p>
</li>
<li>
<p>The task&#8217;s generation number is incremented.</p>
</li>
<li>
<p>The task&#8217;s registers are reset (to particular values where necessary, and to
zero otherwise) and the stack erased.</p>
</li>
<li>
<p>The task&#8217;s interrupts are disabled and its timer is stopped.</p>
</li>
<li>
<p>Any <em>other</em> tasks that were blocked in IPC with the targeted task (either
waiting to deliver a message, waiting for a reply to a delivered message, or
waiting to receive) are interrupted and given a <a href="#death">dead code</a> to indicate
that the IPC will never complete.  The dead code&#8217;s generation is the <strong>new</strong>
generation number for the faulted task.</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="_request_2">Request</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">struct</span> <span class="n">ReinitRequest</span> <span class="p">{</span>
    <span class="n">task_index</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">start</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_preconditions_2">Preconditions</h5>
<div class="paragraph">
<p>The <code>task_index</code> must be a valid index for this system.</p>
</div>
</div>
<div class="sect4">
<h5 id="_response_2">Response</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">type</span> <span class="n">ReinitResponse</span> <span class="o">=</span> <span class="p">();</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_notes_14">Notes</h5>
<div class="paragraph">
<p>If a task asks to reinit <em>itself,</em> the kernel mumbles &#8220;alright, your funeral&#8221;
and reinits the caller. Given that <code>reinit_task</code> is intended to be restricted to
the supervisor, and the supervisor can&#8217;t <code>panic!</code> to restart without taking out
the system, this seemingly weird move may actually prove useful.</p>
</div>
<div class="paragraph">
<p>Reinitialization <em>does not</em> write over the task&#8217;s memory except for the stack.
Tasks are responsible for (say) setting up their data/BSS areas on start. This
is explicitly intended to allow tasks to keep some information from &#8220;past
lives&#8221; if required.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_fault_task_3">8.1.3. <code>fault_task</code> (3)</h4>
<div class="paragraph">
<p>Forces a task into a <code>Faulted</code> state. Specifically, this will set the task&#8217;s
fault to <code>FaultInfo::Injected(caller)</code>, where <code>caller</code> is the TaskId of the task
that called <code>fault_task</code> (i.e. you). This means that a fault caused by
<code>fault_task</code> is both easily distinguished from any other fault, and traceable.</p>
</div>
<div class="paragraph">
<p><code>fault_task</code> immediately prevents the targeted task from running, and any
<em>other</em> tasks that were blocked in IPC with the targeted task are interrupted
and given a <a href="#death">dead code</a> to indicate that the IPC will never complete.</p>
</div>
<div class="sect4">
<h5 id="_request_3">Request</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">struct</span> <span class="n">FaultRequest</span> <span class="p">{</span>
    <span class="n">task_index</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_preconditions_3">Preconditions</h5>
<div class="paragraph">
<p>The <code>task_index</code> must be a valid index for this system.</p>
</div>
</div>
<div class="sect4">
<h5 id="_response_3">Response</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">type</span> <span class="n">FaultResponse</span> <span class="o">=</span> <span class="p">();</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_notes_15">Notes</h5>
<div class="paragraph">
<p>As with <code>reinit_task</code>, it is possible for a task to use <code>fault_task</code> to fault
<em>itself.</em> This is an odd thing to do.</p>
</div>
<div class="paragraph">
<p>On faults, the kernel tries to save the pre-fault state of the task. However, if
you apply <code>fault_task</code> to an already-faulted task, the task will be marked as
double-faulted and the previous fault will be replaced with the new injected
fault.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_read_image_id_4">8.1.4. <code>read_image_id</code> (4)</h4>

</div>
<div class="sect3">
<h4 id="_reset_5">8.1.5. <code>reset</code> (5)</h4>

</div>
<div class="sect3">
<h4 id="_get_task_dump_region_6">8.1.6. <code>get_task_dump_region</code> (6)</h4>
<div class="paragraph">
<p>A dump region is an area of memory for a specified task that can be
read by the supervisor for purpose of creating a memory dump for debugging.
For a specified task and region index, <code>get_task_dump_region</code>
will return the details of the dump region, if any.  This entry point
is only present if the kernel&#8217;s <code>dump</code> feature is enabled.</p>
</div>
<div class="sect4">
<h5 id="_request_4">Request</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">type</span> <span class="n">GetTaskDumpRegionRequest</span> <span class="o">=</span> <span class="p">(</span><span class="nb">u32</span><span class="p">,</span> <span class="nb">u32</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_preconditions_4">Preconditions</h5>
<div class="paragraph">
<p>The task index (<code>GetTaskDumpRegionRequest.0</code>) must be a valid task index.  The
dump region index (<code>GetTaskDumpRegionRequest.1</code>) should denote the region of
interest.</p>
</div>
</div>
<div class="sect4">
<h5 id="_response_4">Response</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">struct</span> <span class="n">TaskDumpRegion</span> <span class="p">{</span>
    <span class="n">base</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">size</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">GetTaskDumpRegionResponse</span> <span class="o">=</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">TaskDumpRegion</span><span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_notes_16">Notes</h5>
<div class="paragraph">
<p>For the specified task index, this will return the dump region specified by
the dump region index.  If the dump region index is equal to or greater
than the number of dump regions for the specified task, <code>None</code> will
be returned.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_read_task_dump_region_7">8.1.7. <code>read_task_dump_region</code> (7)</h4>
<div class="paragraph">
<p>For a given task and task dump region, this will read the specified region and
return its contents.  The region should be entirely contained by a region that
has been returned by a call to <code>get_task_dump_region</code> but is otherwise
unconstrained.  This entry point is only present if the kernel&#8217;s <code>dump</code>
feature is enabled.</p>
</div>
<div class="sect4">
<h5 id="_request_5">Request</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">struct</span> <span class="n">TaskDumpRegion</span> <span class="p">{</span>
    <span class="n">base</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">size</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ReadTaskDumpRegionRequest</span> <span class="o">=</span> <span class="p">(</span><span class="nb">u32</span><span class="p">,</span> <span class="n">TaskDumpRegion</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_preconditions_5">Preconditions</h5>
<div class="paragraph">
<p>The task index (<code>ReadTaskDumpRegionRequest.0</code>) must be a valid task index.
The dump region should be entirely contained by a region that has been
returned by a call to <code>get_task_dump_region</code> for the specified task.</p>
</div>
</div>
<div class="sect4">
<h5 id="_response_5">Response</h5>
<div class="paragraph">
<p>A copy of the memory referred to by the specified region, starting
at <code>base</code> and running for <code>size</code> bytes.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_software_irq_8">8.1.8. <code>software_irq</code> (8)</h4>
<div class="paragraph">
<p>For a given task index and a notification mask for that task, this will
trigger software interrupts for any IRQ(s) mapped to bits in that task&#8217;s
notification set.</p>
</div>
<div class="paragraph">
<p>Any interrupts triggered through this mechanism will be delivered to the
that task identically to an actual hardware interrupt, as described in
the <a href="#interrupts-from-a-tasks-perspective">the documentation on interrupts</a>.</p>
</div>
<div class="sect4">
<h5 id="_request_6">Request</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">type</span> <span class="n">SoftwareIrqRequest</span> <span class="o">=</span> <span class="p">(</span><span class="nb">u32</span><span class="p">,</span> <span class="nb">u32</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_preconditions_6">Preconditions</h5>
<div class="paragraph">
<p>The task index (<code>SoftwareIrqRequest.0</code>) must be a valid task index.</p>
</div>
<div class="paragraph">
<p>The notification mask (<code>SoftwareIrqRequest.1</code>) should be a valid notification
mask for the specified task, and should have at least one bit set. Any bits
set in the notification mask should be assigned to hardware interrupts in
the task&#8217;s build-time configuration.</p>
</div>
<div class="paragraph">
<p>The caller <strong>must</strong> be the supervisor (task index 0).</p>
</div>
</div>
<div class="sect4">
<h5 id="_response_6">Response</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">type</span> <span class="n">SoftwareIrqResponse</span> <span class="o">=</span> <span class="p">();</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_notes_17">Notes</h5>
<div class="paragraph">
<p>This interface is primarily intended for testing interrupt handling, and can
only be called by a task running as the supervisor. When this KIPC is called,
an actual machine interrupt is triggered for the relevant hardware interrupt
source. The kernel then responds to the interrupt using its normal
interrupt-handling infrastructure, which dispatches a notification to the
subscribed task.</p>
</div>
<div class="paragraph">
<p>This KIPC is <strong>not</strong> intended for use as a general-purpose inter-task signalling
mechanism. For that purpose, a <a href="#notifications">notification</a> should be used
instead.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_find_faulted_task_9">8.1.9. <code>find_faulted_task</code> (9)</h4>
<div class="paragraph">
<p>Scans forward from a given task index searching for a faulted task. If a faulted
task is found, returns its index. Otherwise, returns zero, the index of the
supervisor task, which is by definition not faulted.</p>
</div>
<div class="paragraph">
<p>To simplify supervisor implementations, the given task index may equal the
number of tasks in the system. In this case, there are no tasks to search, and
you always get zero back.</p>
</div>
<div class="paragraph">
<p>We do <em>not</em> permit greater indices than that, because that would strongly
suggest a bug.</p>
</div>
<div class="sect4">
<h5 id="_request_7">Request</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">struct</span> <span class="n">FindFaultedTaskRequest</span> <span class="p">{</span>
    <span class="n">starting_index</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_preconditions_7">Preconditions</h5>
<div class="paragraph">
<p>The <code>starting_index</code> must be a valid index for this system, or one greater.</p>
</div>
</div>
<div class="sect4">
<h5 id="_response_7">Response</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">struct</span> <span class="n">FindFaultedTaskResponse</span> <span class="p">{</span>
    <span class="n">fault_index</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_notes_18">Notes</h5>
<div class="paragraph">
<p>This is intended for the common case of a supervisor scanning the task table in
search of a fault. Compared to doing this manually with <code>read_task_status</code>,
<code>find_faulted_task</code> has several advantages:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Generates one kipc per failed task, plus one, rather than one kipc per
potentially failed task.</p>
</li>
<li>
<p>Avoids serializing/transferring/deserializing the relatively complex
<code>TaskState</code> type, which supervisors rarely make use of in practice.</p>
</li>
<li>
<p>Can be implemented in a way that doesn&#8217;t potentially panic the supervisor.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The "task ID or zero" return value is represented as an <code>Option&lt;NonZeroUsize&gt;</code>
in the Rust API, so a typical use of this kipc looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">next_task</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// skip supervisor</span>
<span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">fault</span><span class="p">)</span> <span class="o">=</span> <span class="nn">kipc</span><span class="p">::</span><span class="nf">find_faulted_task</span><span class="p">(</span><span class="n">next_task</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">fault</span> <span class="o">=</span> <span class="nn">usize</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">fault</span><span class="p">);</span>
    <span class="c1">// do things with the faulted task</span>

    <span class="n">next_task</span> <span class="o">=</span> <span class="n">fault</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_receiving_from_the_kernel">8.2. Receiving from the kernel</h3>
<div class="paragraph">
<p>The kernel never sends messages to tasks. It&#8217;s simply not equipped to do so.
However, it is legal to enter a closed receive from the kernel. This might be
counter-intuitive&#8201;&#8212;&#8201;since the kernel will never send a message for you to
receive, it sure sounds like a programming error, and Hubris as a rule tries to
turn obvious programming errors into crashes.</p>
</div>
<div class="paragraph">
<p>Receiving from the kernel is deliberately allowed to enable two use cases:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Blocking the current task until a notification arrives while ignoring all
incoming messages.</strong> By receiving from the kernel&#8217;s task ID with a non-zero
notification mask, the current task will wait until any matching notification
arrives.</p>
</li>
<li>
<p><strong>Halting the current task.</strong> If you really want to stop the current task
forever (or at least, until the supervisor reinits it), you can receive from the
kernel with <em>no</em> notification mask bits set.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We haven&#8217;t needed that second one in practice, so we might make it an
error someday. The first one, on the other hand, is useful.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_application_notes">9. Application Notes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_servers">9.1. Servers</h3>
<div class="paragraph">
<p>A <strong>server</strong> in Hubris is any task that receives messages to implement some API.
This section looks at how servers work, how to implement one using low and high
level APIs, and provides some tips.</p>
</div>
<div class="sect3">
<h4 id="_the_role_of_a_server">9.1.1. The role of a server</h4>
<div class="paragraph">
<p>Servers normally spend most of their time hanging out in RECV. This ensures that
they&#8217;re ready to handle incoming messages.</p>
</div>
<div class="paragraph">
<p>In the simplest case, after doing any initialization required on startup, a
server will:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>RECV to collect a request.</p>
</li>
<li>
<p>Inspect the request and figure out what needs to be done.</p>
</li>
<li>
<p>Do it.</p>
</li>
<li>
<p>Reply.</p>
</li>
<li>
<p>Repeat.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This simple version covers <em>most</em> servers on Hubris, believe it or not. All the
complexity, and application-specific logic, is hidden in the "do it" step.</p>
</div>
</div>
<div class="sect3">
<h4 id="uphill-send">9.1.2. Servers are clients too</h4>
<div class="paragraph">
<p>The vast majority of servers need to send messages to other servers to do their
jobs. Most servers will turn a single incoming client message into a sequence of
messages to other servers to perform useful work.</p>
</div>
<div class="paragraph">
<p>When designing a collection of servers in an application, remember that it&#8217;s
only safe to send messages to <em>higher priority</em> servers (called the "uphill send
rule"). Sending messages to lower priority servers can cause starvation and
deadlock.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The kernel will enforce this, eventually.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_when_not_to_use_a_server">9.1.3. When <em>not</em> to use a server</h4>
<div class="paragraph">
<p>Servers are tasks. Tasks are relatively expensive&#8201;&#8212;&#8201;they require separate code
and data storage and stack space. When designing an API consider whether it
should be a server task&#8201;&#8212;&#8201;or just a crate.</p>
</div>
<div class="paragraph">
<p>You may want a server if any of these are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>There will be several client tasks, particularly if it&#8217;s important for only
one of them to be performing an operation at a time (mutual exclusion).</p>
</li>
<li>
<p>The implementation needs to do something clever or <code>unsafe</code>, such that you
want it isolated in memory away from other tasks.</p>
</li>
<li>
<p>You need the code to be able to crash and restart separately from other code.</p>
</li>
<li>
<p>You need to have multiple concurrent state machines responding to messages and
notifications. (This is hard to do inside another task.)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Signs that you may just want a crate:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This task and another task (or a whole group of tasks!) will <em>never</em> be
runnable at the same time. For instance, only one device driver on an I2C bus
can be using the bus at any given time. (See the section on drivers, below.)</p>
</li>
<li>
<p>There will be a single client, <em>or</em> there will be multiple clients but the
code is fairly small and no mutual-exclusion is required.</p>
</li>
<li>
<p>You don&#8217;t expect crashes and can return <code>Err</code> for failures.</p>
</li>
<li>
<p>You&#8217;re not being weird with <code>unsafe</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_low_level_syscall_implementation">9.1.4. Low-level (syscall) implementation</h4>
<div class="paragraph">
<p>Here is a full implementation of a server for a very simple IPC protocol: it
maintains a 32-bit integer, and can add or subtract values and return the
result.</p>
</div>
<div class="paragraph">
<p>This implementation uses syscalls directly and no abstractions, to show you
exactly what&#8217;s happening under the hood. In practice, we rarely write servers
this way&#8201;&#8212;&#8201;the next section shows a higher-level equivalent.</p>
</div>
<div class="paragraph">
<p>This server supports two messages, <code>add</code> (0) and <code>sub</code> (1). Both messages expect
a four-byte payload, which is a <code>u32</code> in little-endian byte order. On success,
the messages update the server state <code>the_integer</code> and return the new value, as
another four-byte little-endian integer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="nd">#![no_std]</span>
<span class="nd">#![no_main]</span>

<span class="k">use</span> <span class="nn">userlib</span><span class="p">::{</span><span class="n">sys_recv_open</span><span class="p">,</span> <span class="n">sys_reply</span><span class="p">};</span>

<span class="k">enum</span> <span class="n">Errs</span> <span class="p">{</span>
    <span class="n">BadMsg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[export_name</span> <span class="nd">=</span> <span class="s">"main"</span><span class="nd">]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">!</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">the_integer</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">msg</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">4</span><span class="p">];</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">msginfo</span> <span class="o">=</span> <span class="nf">sys_recv_open</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <i class="conum" data-value="3"></i><b>(3)</b>

        <span class="k">match</span> <span class="n">msginfo</span><span class="py">.operation</span> <span class="p">{</span> <i class="conum" data-value="4"></i><b>(4)</b>
            <span class="mi">0</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c1">// Add</span>
                <span class="k">if</span> <span class="n">msginfo</span><span class="py">.message_len</span> <span class="o">==</span> <span class="mi">4</span> <span class="p">{</span> <i class="conum" data-value="5"></i><b>(5)</b>
                    <span class="c1">// yay!</span>
                    <span class="n">the_integer</span> <span class="o">=</span> <span class="n">the_integer</span><span class="nf">.wrapping_add</span><span class="p">(</span>
                        <span class="nn">u32</span><span class="p">::</span><span class="nf">from_le_bytes</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="p">);</span>
                    <span class="nf">sys_reply</span><span class="p">(</span><span class="n">msginfo</span><span class="py">.sender</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">the_integer</span><span class="nf">.to_le_bytes</span><span class="p">());</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nf">sys_reply</span><span class="p">(</span><span class="n">msginfo</span><span class="py">.sender</span><span class="p">,</span> <span class="nn">Errs</span><span class="p">::</span><span class="n">BadMsg</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[]);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="mi">1</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c1">// Subtract</span>
                <span class="k">if</span> <span class="n">msginfo</span><span class="py">.message_len</span> <span class="o">==</span> <span class="mi">4</span> <span class="p">{</span>
                    <span class="c1">// yay!</span>
                    <span class="n">the_integer</span> <span class="o">=</span> <span class="n">the_integer</span><span class="nf">.wrapping_sub</span><span class="p">(</span>
                        <span class="nn">u32</span><span class="p">::</span><span class="nf">from_le_bytes</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="p">);</span>
                    <span class="nf">sys_reply</span><span class="p">(</span><span class="n">msginfo</span><span class="py">.sender</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">the_integer</span><span class="nf">.to_le_bytes</span><span class="p">());</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nf">sys_reply</span><span class="p">(</span><span class="n">msginfo</span><span class="py">.sender</span><span class="p">,</span> <span class="nn">Errs</span><span class="p">::</span><span class="n">BadMsg</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[]);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span> <i class="conum" data-value="6"></i><b>(6)</b>
                <span class="c1">// Unknown operation</span>
                <span class="nf">sys_reply</span><span class="p">(</span><span class="n">msginfo</span><span class="py">.sender</span><span class="p">,</span> <span class="nn">Errs</span><span class="p">::</span><span class="n">BadMsg</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is the server&#8217;s local state. It&#8217;s common for servers to keep their
state on the stack, but larger state might be better placed in a <code>static</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The server maintains a 4-byte buffer for incoming messages. This means that
any longer message will be truncated.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The server uses <code>sys_recv_open</code> to accept messages from any caller. The
notification mask is 0, ensuring that we won&#8217;t get any notifications instead of
messages.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>operation</code> code distinguishes the operations we implement, so we
<code>match</code> on it.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>It&#8217;s important to check <code>message_len</code>, since clients can send a message that
is too short or too long. Too-long messages get truncated, but <code>message_len</code>
will be honest, so if the <code>message_len</code> here were 6, we&#8217;d know the client sent a
truncated message.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Clients can choose any operation code they want, so we need to make sure to
have a default case to signal errors.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_high_level_wrapper_implementation">9.1.5. High-level (wrapper) implementation</h4>
<div class="paragraph">
<p>The <code>userlib::hl</code> module provides wrappers for common patterns in server
implementation. Here&#8217;s the same server from the last section, rewritten using
the <code>hl</code> conveniences.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="nd">#![no_std]</span>
<span class="nd">#![no_main]</span>

<span class="k">use</span> <span class="nn">userlib</span><span class="p">::{</span><span class="n">hl</span><span class="p">,</span> <span class="n">FromPrimitive</span><span class="p">};</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="k">use</span> <span class="nn">zerocopy</span><span class="p">::</span><span class="n">IntoBytes</span><span class="p">;</span>

<span class="nd">#[derive(FromPrimitive)]</span>
<span class="k">enum</span> <span class="n">Op</span> <span class="p">{</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="nb">Add</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nb">Sub</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">ResponseCode</span> <span class="p">{</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="c1">// Note: code 1 is produced by hl</span>
    <span class="n">BadArg</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">From</span><span class="o">&lt;</span><span class="n">ResponseCode</span><span class="o">&gt;</span> <span class="k">for</span> <span class="nb">u32</span> <span class="p">{</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">rc</span><span class="p">:</span> <span class="n">ResponseCode</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">rc</span> <span class="k">as</span> <span class="nb">u32</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[export_name</span> <span class="nd">=</span> <span class="s">"main"</span><span class="nd">]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">!</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">the_integer</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <i class="conum" data-value="5"></i><b>(5)</b>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">argument</span> <span class="o">=</span> <span class="mi">0u32</span><span class="p">;</span> <i class="conum" data-value="6"></i><b>(6)</b>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">hl</span><span class="p">::</span><span class="nf">recv_without_notification</span><span class="p">(</span> <i class="conum" data-value="7"></i><b>(7)</b>
            <span class="n">argument</span><span class="nf">.as_mut_bytes</span><span class="p">(),</span> <i class="conum" data-value="8"></i><b>(8)</b>
            <span class="p">|</span><span class="n">op</span><span class="p">,</span> <span class="n">msg</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">ResponseCode</span><span class="o">&gt;</span> <span class="p">{</span> <i class="conum" data-value="9"></i><b>(9)</b>
                <span class="k">let</span> <span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">caller</span><span class="p">)</span> <span class="o">=</span> <span class="n">msg</span><span class="py">.fixed</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="nb">u32</span><span class="o">&gt;</span><span class="p">()</span> <i class="conum" data-value="10"></i><b>(10)</b>
                    <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">ResponseCode</span><span class="p">::</span><span class="n">BadArg</span><span class="p">)</span><span class="o">?</span><span class="p">;</span> <i class="conum" data-value="11"></i><b>(11)</b>

                <span class="k">match</span> <span class="n">op</span> <span class="p">{</span> <i class="conum" data-value="12"></i><b>(12)</b>
                    <span class="nn">Op</span><span class="p">::</span><span class="nb">Add</span> <span class="k">=&gt;</span> <span class="n">the_integer</span><span class="nf">.wrapping_add</span><span class="p">(</span><span class="n">argument</span><span class="p">),</span>
                    <span class="nn">Op</span><span class="p">::</span><span class="nb">Sub</span> <span class="k">=&gt;</span> <span class="n">the_integer</span><span class="nf">.wrapping_sub</span><span class="p">(</span><span class="n">argument</span><span class="p">),</span>
                <span class="p">}</span>

                <span class="n">caller</span><span class="nf">.reply</span><span class="p">(</span><span class="n">the_integer</span><span class="p">);</span> <i class="conum" data-value="13"></i><b>(13)</b>
                <span class="nf">Ok</span><span class="p">(())</span> <i class="conum" data-value="14"></i><b>(14)</b>
            <span class="p">},</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>userlib::hl</code> module provides these utilities for implementing clients
and servers, and is intended to be imported as <code>hl</code> like this, so references to
it in the file are prefixed with <code>hl::</code>. We also import the <code>FromPrimitive</code>
derive macro for our <code>Op</code> enum below.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We now describe the possible operation codes using an enum. Any operation
outside this set will automatically generate an error reply to the client.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Errors are still described in an enum, but <code>hl</code> directly supports this as
long as we provide a <code>From</code> impl for <code>u32</code>. We skip code 1 as it&#8217;s used by <code>hl</code>
to indicate an illegal operation code.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Here&#8217;s our impl. It&#8217;s unfortunate that Rust can&#8217;t derive this, but, it
can&#8217;t.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Server state is still kept on the stack as a <code>u32</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>This is our incoming argument buffer. Since all incoming messages use the
same argument type, <code>u32</code>, <code>hl</code> lets us use it directly instead of dealing in
byte arrays.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td><code>recv_without_notification</code> wraps up the open receive pattern used by most
servers.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>We pass the argument buffer in using <code>zerocopy::IntoBytes</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>This closure handles messages. The <code>op</code> parameter is automatically converted
to the <code>Op</code> enum by <code>hl</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>The <code>fixed</code> operation requires that the argument exactly match the size of
its first type (here, <code>u32</code>), wrapping up the common case where arguments are
fixed-size.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>If we can&#8217;t parse the message as a <code>u32</code> we bail with <code>BadArg</code>. <code>hl</code> is
designed so we can use <code>?</code> to signal errors here.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>And now, we <code>match</code> on the operation code. We no longer need a default
case, as <code>hl</code> has already filtered out unknown codes.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>The <code>caller</code> type returned from <code>fixed</code> has a convenient <code>reply</code> operation
that also checks that the types match.</td>
</tr>
<tr>
<td><i class="conum" data-value="14"></i><b>14</b></td>
<td>And, we&#8217;re done.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_api_wrapper_crates">9.1.6. API wrapper crates</h4>
<div class="paragraph">
<p>It&#8217;s polite to provide a <em>wrapper crate</em> that turns your server&#8217;s IPC API into a
Rust API. We write these by hand at the moment, since we don&#8217;t have any sort of
IDL. The general pattern is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create a crate ending in <code>-api</code>, e.g. for the <code>fnord</code> service it would be
<code>fnord-api</code> by convention.</p>
</li>
<li>
<p>Implement a "server handle" type that wraps your server&#8217;s <code>TaskId</code> and
represents the server.</p>
</li>
<li>
<p>Provide operations on that type that correspond to IPCs, or combinations of
IPCs.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The wrapper crate should not depend on the server implementation crate. This may
require moving types around.</p>
</div>
<div class="paragraph">
<p>One of the decisions wrapper crates must make is how to handle server death&#8201;&#8212;&#8201;that is, what if the server crashes while the client is talking to it, or
between messages? There are three common ways to respond.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Crash. If the client and server are engaged in some sort of stateful
protocol, the client may not be <em>able</em> to recover from a server restart, and
want to restart itself in response. This effectively propagates the crash out
through a tree of dependent tasks, putting them all back in a known-good state.</p>
</li>
<li>
<p>Retry. If the request to the server is idempotent, the client may just want
to update their TaskId to the server&#8217;s new generation and re-send. (That&#8217;s what
the demo below does.)</p>
</li>
<li>
<p>Return an error. This lets the caller decide whether to retry. In practice, a
lot of callers will <code>unwrap</code> this error, which is a sign that the wrapper crate
should have chosen approach #1.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Here is a wrapper crate for the server presented earlier in this chapter,
expressed entirely using low-level Hubris API, under the assumption that we just
want to retry on server restart:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="nd">#![no_std]</span>

<span class="k">use</span> <span class="nn">abi</span><span class="p">::</span><span class="n">TaskId</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">core</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">Cell</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">userlib</span><span class="p">::</span><span class="n">sys_send</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">zerocopy</span><span class="p">::</span><span class="n">IntoBytes</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">Op</span> <span class="p">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="nb">Add</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nb">Sub</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="nf">IntServer</span><span class="p">(</span><span class="n">Cell</span><span class="o">&lt;</span><span class="n">TaskId</span><span class="o">&gt;</span><span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>

<span class="k">impl</span> <span class="n">IntServer</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">tid</span><span class="p">:</span> <span class="n">TaskId</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="nn">Cell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">tid</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="cd">/// Adds `value` to the server's integer, returning the new</span>
    <span class="cd">/// integer.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.send</span><span class="p">(</span><span class="nn">Op</span><span class="p">::</span><span class="nb">Add</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="cd">/// Subtracts `value` to the server's integer, returning the</span>
    <span class="cd">/// new integer.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">sub</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.send</span><span class="p">(</span><span class="nn">Op</span><span class="p">::</span><span class="nb">Sub</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// Common implementation bit of add and sub, which</span>
    <span class="c1">// differ only in Op</span>
    <span class="k">fn</span> <span class="nf">send</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="n">Op</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">response</span> <span class="o">=</span> <span class="mi">0u32</span><span class="p">;</span>
        <span class="k">loop</span> <span class="p">{</span> <i class="conum" data-value="3"></i><b>(3)</b>
            <span class="k">let</span> <span class="n">target</span> <span class="o">=</span> <span class="k">self</span><span class="na">.0</span><span class="nf">.get</span><span class="p">();</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">response_len</span><span class="p">)</span> <span class="o">=</span> <i class="conum" data-value="4"></i><b>(4)</b>
                <span class="nf">sys_send</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">value</span><span class="nf">.as_bytes</span><span class="p">(),</span> <span class="n">response</span><span class="nf">.as_mut_bytes</span><span class="p">());</span>

            <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">response_len</span> <span class="o">==</span> <span class="mi">4</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">response</span><span class="p">;</span> <i class="conum" data-value="5"></i><b>(5)</b>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nf">Some</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">=</span> <span class="nn">abi</span><span class="p">::</span><span class="nf">extract_new_generation</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// The int server has crashed, let's just retry. </span><i class="conum" data-value="6"></i><b>(6)</b>
                <span class="k">self</span><span class="na">.0</span><span class="nf">.set</span><span class="p">(</span> <i class="conum" data-value="7"></i><b>(7)</b>
                    <span class="nn">TaskId</span><span class="p">::</span><span class="nf">for_index_and_gen</span><span class="p">(</span><span class="n">target</span><span class="nf">.index</span><span class="p">(),</span> <span class="n">g</span><span class="p">)</span>
                <span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">panic!</span><span class="p">();</span> <i class="conum" data-value="8"></i><b>(8)</b>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This duplicates the <code>Op</code> enum from the server, and could be shared with some
rearranging.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Clients will manipulate an <code>IntServer</code> as a sort of "handle" to the server,
hiding a <code>TaskId</code> that they need not concern themselves with.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The send implementation is in a loop so that it can retry until it succeeds.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Here we send a message to what we <em>believe</em> is the right <code>TaskId</code>, though we
may find out otherwise shortly&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A 0 return code means success&#8201;&#8212;&#8201;the easy path.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td><code>abi::extract_new_generation</code> is a function for analyzing "dead codes"
received over IPC. If a result value indicates peer death, it will return
<code>Some(gen)</code> where <code>gen</code> is the peer&#8217;s new generation number after restart.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Here, we update our internal state to keep track of the correct server
generation.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>It may surprise you to see <code>panic!</code> here. More on this below.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now, notice that the server can generate error codes, such as <code>BadArg</code> if the
buffers are the wrong size, but the client doesn&#8217;t have any representation for
them. This is deliberate. In the case of the integer server protocol, <em>all</em>
potential errors returned from IPCs represent <em>programming errors</em> in the
client:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use of an undefined operation code like 3 or 119,</p>
</li>
<li>
<p>Sending a too-small or too-big message, or</p>
</li>
<li>
<p>Providing the wrong size of response buffer.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the first two cases the server will return a non-zero response code; in the
last case, it will succeed, but the <code>response_len</code> will show that our response
was truncated. Either case represents a mismatch between the wrapper crate and
the server, and the normal thing to do in such situations on Hubris is to
<code>panic!</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_pipelining">9.1.7. Pipelining</h4>
<div class="paragraph">
<p>The server loop described above handles a single request at a time. Things
become more complex if the server wants to be able to handle multiple requests
concurrently. In that case, the <em>reply</em> step is delayed until the work actually
completes, so the server may RECV another message before replying to the first.</p>
</div>
<div class="paragraph">
<p>For each incoming request, the server needs to record <em>at least</em> the caller&#8217;s
Task ID, so that it can respond. In practice, the server will also need to
record some details about each request, and some information about the state of
processing. While it&#8217;s nice to pretend that we can resize buffers forever,
that&#8217;s simply not the environment we work in. Eventually, the server&#8217;s internal
storage for this sort of thing will fill up. At this point, the server should
finish at least one outstanding request before doing another RECV.</p>
</div>
<div class="paragraph">
<p>Typically, a pipelined server will keep information about outstanding requests
in a table. The maximum size of that table is dictated by the number of
potential clients. If the server has specific knowledge of this number in the
application, it can use that to size the table&#8201;&#8212;&#8201;or it be conservative and set
the size of the table to <code>hubris_num_tasks::NUM_TASKS</code>, the number of tasks in
the system. Such a table should never overflow.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Remember that tasks can restart&#8201;&#8212;&#8201;any table tracking per-task state
should be indexed by task <em>index</em> and record the generation. If a new request
arrives from the same task index but a different generation, the request should
be halted and replaced.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="supervisor">9.2. Supervision</h3>
<div class="paragraph">
<p>Rather than doing things like crash recovery in the kernel, Hubris assigns the
responsibility to a designated task, called the <em>supervisor.</em> This section
discusses the role of the supervisor and provides suggestions for writing your
own.</p>
</div>
<div class="paragraph">
<p>The Hubris repo contains our reference supervisor implementation, <em>El Jefe</em>, in
the <code>task-jefe</code> directory.</p>
</div>
<div class="sect3">
<h4 id="_what_is_the_supervisor">9.2.1. What is the supervisor?</h4>
<div class="paragraph">
<p>The supervisor is a task like any other. It is compiled with the application,
runs in the processor&#8217;s unprivileged mode, and is subject to memory protection.</p>
</div>
<div class="paragraph">
<p>Two things make the supervisor different from other tasks:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It runs at the highest task priority, 0, and is the only task at this
priority.</p>
</li>
<li>
<p>The kernel recognizes it and interacts with it in unique ways.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The kernel can spot the supervisor because <strong>the supervisor always has task
index 0,</strong> and is listed first in the <code>app.toml</code>. The kernel treats task index 0
differently:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When any <em>other</em> task crashes, the kernel posts a notification to the
supervisor task. This notification is always sent to bit 0 (i.e. the
value <code>1</code>).</p>
</li>
<li>
<p>The supervisor task is allowed to send any kernel IPC message.</p>
</li>
<li>
<p>If the supervisor task crashes, <strong>the system reboots.</strong></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_what_does_the_supervisor_do">9.2.2. What does the supervisor do?</h4>
<div class="paragraph">
<p>The design of Hubris assumes that the supervisor is responsible for taking
action on task crashes. It may also do other things, but, that&#8217;s the basics.</p>
</div>
<div class="paragraph">
<p>When any task crashes, the kernel will post a notification to the supervisor
task (as chosen by the <code>supervisor.notification</code> key in the <code>app.toml</code>). Since
notifications don&#8217;t carry data payloads, this tells the supervisor that
<em>something</em> has crashed, but not <em>what</em> or <em>why</em>. The supervisor can use kernel
IPC messages to figure out the rest.</p>
</div>
<div class="paragraph">
<p>Currently, the supervisor needs to scan the set of tasks using the
<code>read_task_state</code> kernel IPC until it finds faults. (If the supervisor sometimes
lets tasks stay in faulted states, then it will need to keep track of that and
look for <em>new</em> faults here.) It can then record that fault information somewhere
(maybe a log) and use the <code>reinit_task</code> call to fix the problem.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Having to scan across the set of tasks is a little lame; if it proves to
be an issue in practice we&#8217;ll introduce a more efficient way of pulling the last
crash(es) from the kernel via IPC.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The basic supervisor main loop reads, then, reads as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="c1">// Value chosen in app.toml.</span>
<span class="k">const</span> <span class="n">CRASH_NOTIFICATION</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">loop</span> <span class="p">{</span>
    <span class="c1">// Closed receive will only accept notifications.</span>
    <span class="k">let</span> <span class="n">msg</span> <span class="o">=</span> <span class="nf">sys_recv_closed</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[],</span>
        <span class="n">CRASH_NOTIFICATION</span><span class="p">,</span>
        <span class="nn">TaskId</span><span class="p">::</span><span class="n">KERNEL</span><span class="p">,</span>
    <span class="p">);</span>

    <span class="c1">// This case is so simple that we don't need to inspect</span>
    <span class="c1">// the message to distinguish different sources. See</span>
    <span class="c1">// below for a more complex example.</span>

    <span class="c1">// Scan tasks. Skip ourselves at index 0.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..</span><span class="nn">hubris_num_tasks</span><span class="p">::</span><span class="n">NUM_TASKS</span> <span class="p">{</span>
        <span class="k">match</span> <span class="nn">userlib</span><span class="p">::</span><span class="nn">kipc</span><span class="p">::</span><span class="nf">read_task_status</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="nn">abi</span><span class="p">::</span><span class="nn">TaskState</span><span class="p">::</span><span class="n">Faulted</span> <span class="p">{</span> <span class="n">fault</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c1">// Record any observed faults and restart.</span>
                <span class="k">log</span><span class="p">(</span><span class="n">fault</span><span class="p">);</span>
                <span class="nn">kipc</span><span class="p">::</span><span class="nf">reinit_task</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>(This is almost verbatim from the reference implementation.)</p>
</div>
</div>
<div class="sect3">
<h4 id="_talking_to_the_supervisor">9.2.3. Talking to the supervisor</h4>
<div class="paragraph">
<p>A supervisor may expose an IPC interface that can be used by other tasks to
report information. (Because the supervisor is the highest priority task, any
task can SEND to it, but it is not allowed to SEND anywhere but the kernel.)</p>
</div>
<div class="paragraph">
<p>Why would you want to do this? Some examples might include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In a simple system, the supervisor might maintain the system&#8217;s event log in a
circular RAM buffer, and provide an IPC for other tasks to append information
to it.</p>
</li>
<li>
<p>You could implement interactive health monitoring (see next section).</p>
</li>
<li>
<p>You could proxy kernel IPCs that are normally only available to the
supervisor, optionally implementing restrictions or filters.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the supervisor wishes to expose an IPC interface, its main loop changes as
follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="c1">// Value chosen in app.toml.</span>
<span class="k">const</span> <span class="n">CRASH_NOTIFICATION</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// However large our biggest incoming message will be.</span>
<span class="k">const</span> <span class="n">MAX_MSG</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

<span class="k">loop</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">msgbuf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0u8</span><span class="p">;</span> <span class="n">MAX_MSG</span><span class="p">];</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="k">let</span> <span class="n">msg</span> <span class="o">=</span> <span class="nf">sys_recv_open</span><span class="p">(</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="n">msgbuf</span><span class="p">,</span>
        <span class="n">CRASH_NOTIFICATION</span><span class="p">,</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="n">msg</span><span class="py">.sender</span> <span class="o">==</span> <span class="nn">TaskId</span><span class="p">::</span><span class="n">KERNEL</span> <span class="p">{</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="c1">// Scan tasks. Skip ourselves at index 0.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..</span><span class="nn">hubris_num_tasks</span><span class="p">::</span><span class="n">NUM_TASKS</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nn">userlib</span><span class="p">::</span><span class="nn">kipc</span><span class="p">::</span><span class="nf">read_task_status</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="nn">abi</span><span class="p">::</span><span class="nn">TaskState</span><span class="p">::</span><span class="n">Faulted</span> <span class="p">{</span> <span class="n">fault</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="c1">// Record any observed faults and restart.</span>
                    <span class="k">log</span><span class="p">(</span><span class="n">fault</span><span class="p">);</span>
                    <span class="nn">kipc</span><span class="p">::</span><span class="nf">reinit_task</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// This is a message from a task</span>
        <span class="k">match</span> <span class="n">msg</span><span class="py">.operation</span> <span class="p">{</span> <i class="conum" data-value="4"></i><b>(4)</b>
            <span class="o">...</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The loop now needs a buffer for depositing incoming messages.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Instead of a closed receive, we use an open receive to accept both
notifications and messages from any source.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We need to distinguish notifications from messages by checking the origin.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>In the case of a message, we choose different actions based on the operation
code.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="drivers">9.3. Drivers</h3>
<div class="paragraph">
<p>One of the purposes of an operating system is to provide a driver abstraction
for talking to hardware. Most traditional monolithic kernels (e.g. Linux)
have applications making system calls (<code>read</code>, <code>write</code>, <code>ioctl</code>) directly
into the kernel where drivers live:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>        +-----------+   +-----------+   +-----------+
        |application|   |application|   |application|
        +-----------+   +-----------+   +-----------+
             |            |        |         |
             |            |        |         |
       +-------------------------------------------------+
             |            |        |         |
          +--v---+   +----v-+   +--v---+   +-v----+
          |driver|   |driver|   |driver|   |driver|
          +------+   +------+   +------+   +------+</code></pre>
</div>
</div>
<div class="paragraph">
<p>In Hubris, drivers are unprivileged and don&#8217;t live in the kernel. The primary
communication method is <code>send</code> and <code>recv</code> between tasks. Hardware drivers
usually exist as a 'server' which listens for messages and changes the hardware
block accordingly. Multiple application tasks may call into a single server.
(This is discussed in more detail in the chapter on servers, above.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>             +-----------+  +-----------+  +-----------+
+------------+ app task  |  | app task  |  | app task  +----------+
|            +--+----+---+  +--+-+---+--+  +-+---------+          |
|               |    |         | |   |       |                    |
|               |    |  +------+ |   +-+  +--+                    |
|               |    |  |        |     |  |                       |
|               v    v  v        v     v  v                       |
|         +------+ +------+ +------+ +------+ +----------+        |
|         |server| |server| |server| |server| |supervisor|        |
|         +---+--+ +--+---+ +---+--+ +--+---+ +----+-----+        |
|      .......|.......|.........|.......|..........|........      |
|         +---v-------v---------v-------v----------v-----+        |
|         |                                              |        |
+--------&gt;+                  kernel                      +&lt;-------+
          |                                              |
          +----------------------------------------------+</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, there&#8217;s some nuance to designing a good driver. This chapter aims to
provide advice on this.</p>
</div>
<div class="sect3">
<h4 id="_driver_crate_vs_server">9.3.1. Driver crate vs server</h4>
<div class="paragraph">
<p>Since tasks are relatively expensive in terms of resources (primarily RAM and
Flash), it&#8217;s important to have the right number of tasks, rather than a separate
task for everything (or just one task).</p>
</div>
<div class="paragraph">
<p>Drivers should not <em>always</em> be servers. Hubris is not religious about this, and
it&#8217;s useful to have some flexibility here.</p>
</div>
<div class="paragraph">
<p>We&#8217;ve found the following distinction to be useful:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <strong>driver crate</strong> provides a Rust interface for dealing with some device. It
may directly access the hardware, or it may make IPCs to other required
servers, or some combination.</p>
</li>
<li>
<p>A <strong>driver server</strong> wraps a driver crate and provides an IPC interface.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By convention, a driver crate for the <code>encoder</code> peripheral on the <code>xyz</code> SoC is
called <code>drv-xyz-encoder</code>, while the crate wrapping it in a server is called
<code>drv-xyz-encoder-server</code>.</p>
</div>
<div class="paragraph">
<p>If, in a given application, there&#8217;s only one user for a given driver&#8201;&#8212;&#8201;say, the
board has a SPI controller with only one device wired to it&#8201;&#8212;&#8201;then it doesn&#8217;t
necessarily make sense to have a task for the SPI controller. Instead, the task
responsible for managing the device could link the SPI driver crate in
<em>directly.</em></p>
</div>
<div class="paragraph">
<p>There&#8217;s also the question of <em>mutual exclusion.</em> On an I2C bus, for instance,
we can only talk to one device at any given time&#8201;&#8212;&#8201;and we may need to issue
several transactions to a single device without risk of interruption. This means
that a single device driver needs exclusive access to the I2C bus, for a
combination of inherent hardware reasons (I2C is not pipelined) and software
requirements.</p>
</div>
<div class="paragraph">
<p>If we allocated a separate server <em>per I2C device,</em> only one of those servers
would be doing useful work at any given time&#8201;&#8212;&#8201;the rest would be waiting their
turn.</p>
</div>
<div class="paragraph">
<p>In this case it might make more sense to assign the task to <em>the bus</em> and have
it call into driver crates for each device as needed. This ensures that we&#8217;re
only spending enough stack space for one device at a time, and helps the device
drivers share common code. It also puts the drivers for the devices and the bus
controller in the same <em>fault domain,</em> so that a crash in one affects the other&#8201;&#8212;&#8201;in I2C, a heavily stateful protocol with poor error recovery, this is almost
certainly what you want, since a crash in a device during a transaction will
likely require global recovery actions on the bus controller.</p>
</div>
</div>
<div class="sect3">
<h4 id="_high_level_server">9.3.2. High Level Server</h4>
<div class="paragraph">
<p>A typical driver server has to multiplex hardware events and client requests,
which requires both configuration in the <code>app.toml</code> and code in the server
itself. Here is an example server written against the <code>userlib::hl</code> library.
(For more details on <code>userlib::hl</code> and server implementations in general, see
the chapter on servers.)</p>
</div>
<div class="paragraph">
<p>Some details are omitted&#8201;&#8212;&#8201;this is pseudocode.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="c1">// Notification mask for interrupts from app.toml</span>
<span class="k">const</span> <span class="n">INTERRUPT</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">turn_on_hardware_clocks</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">B</span> <span class="o">=</span> <span class="nf">get_hardware_block</span><span class="p">();</span>

    <span class="n">B</span><span class="py">.clk</span><span class="nf">.write</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="py">.clock</span><span class="nf">.very_fast</span><span class="p">());</span>

    <span class="n">B</span><span class="py">.cfg</span><span class="nf">.modify</span><span class="p">(|</span><span class="n">_</span><span class="p">,</span> <span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="py">.foo</span><span class="nf">.disable</span><span class="p">()</span><span class="py">.
                enabled</span><span class="nf">.set</span><span class="p">());</span>

    <span class="c1">// Type used to record the state of an ongoing operation.</span>
    <span class="c1">// This is handwavey but is similar to most block transfer</span>
    <span class="c1">// implementations, which track a position and length.</span>
    <span class="k">struct</span> <span class="n">MyData</span> <span class="p">{</span>
        <span class="n">caller</span><span class="p">:</span> <span class="nn">hl</span><span class="p">::</span><span class="n">Caller</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">pos</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="c1">// State of an ongoing operation; None indicates no</span>
    <span class="c1">// operation</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">MyData</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="c1">// This receives with notification, the alternate</span>
        <span class="c1">// version is hl::recv_without_notification</span>
        <span class="nn">hl</span><span class="p">::</span><span class="nf">recv</span><span class="p">(</span>
            <span class="c1">// all our messages are zero length.</span>
            <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[],</span>
            <span class="c1">// notification mask</span>
            <span class="n">INTERRUPT</span><span class="p">,</span>
            <span class="c1">// state shared by notification and message handlers</span>
            <span class="o">&amp;</span><span class="k">mut</span> <span class="n">data</span><span class="p">,</span>
            <span class="c1">// Notification handler</span>
            <span class="p">|</span><span class="n">dataref</span><span class="p">,</span> <span class="n">bits</span><span class="p">|</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">bits</span> <span class="o">&amp;</span> <span class="n">INTERRUPT</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="c1">// Matches our notification for an</span>
                    <span class="c1">// interrupt, do something</span>
                    <span class="n">B</span><span class="py">.fifowr</span><span class="nf">.write</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="py">.out</span><span class="nf">.bits</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>

                    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">=</span> <span class="n">dataref</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="n">B</span><span class="py">.sr</span><span class="nf">.read</span><span class="p">()</span><span class="nf">.is_done</span><span class="p">()</span> <span class="p">{</span>
                            <span class="c1">// Resume the caller we were servicing.</span>
                            <span class="n">state</span><span class="py">.caller</span><span class="nf">.reply</span><span class="p">(());</span>
                            <span class="c1">// Clear the state machine to accept</span>
                            <span class="c1">// more messages.</span>
                            <span class="o">*</span><span class="n">dataref</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">},</span>
            <span class="c1">// Message handler</span>
            <span class="p">|</span><span class="n">dataref</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">msg</span><span class="p">|</span> <span class="k">match</span> <span class="n">op</span> <span class="p">{</span>
                <span class="nn">Op</span><span class="p">::</span><span class="n">Write</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="c1">// We expect a caller with one lease</span>
                    <span class="k">let</span> <span class="p">((),</span> <span class="n">caller</span><span class="p">)</span> <span class="o">=</span> <span class="n">msg</span>
                        <span class="nf">.fixed_with_leases</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">ResponseCode</span><span class="p">::</span><span class="n">BadArg</span><span class="p">)</span><span class="o">?</span>

                    <span class="c1">// Deny incoming writes if we're</span>
                    <span class="c1">// already running one.</span>
                    <span class="k">if</span> <span class="n">dataref</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">ResponseCode</span><span class="p">::</span><span class="n">Busy</span><span class="p">);</span>
                    <span class="p">}</span>

                    <span class="c1">// Our lease #0 is what is being sent to</span>
                    <span class="c1">// the hardware</span>
                    <span class="k">let</span> <span class="n">borrow</span> <span class="o">=</span> <span class="n">caller</span><span class="nf">.borrow</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
                    <span class="k">let</span> <span class="n">info</span> <span class="o">=</span> <span class="n">borrow</span><span class="nf">.info</span><span class="p">()</span>
                        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">ResponseCode</span><span class="p">::</span><span class="n">BadArg</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="c1">// Provide feedback to callers if they</span>
                    <span class="c1">// fail to provide a readable lease</span>
                    <span class="c1">// (otherwise we'd fail accessing the</span>
                    <span class="c1">// borrow later, which is a defection</span>
                    <span class="c1">// case and we won't reply at all).</span>
                    <span class="k">if</span> <span class="o">!</span><span class="n">info</span><span class="py">.attributes</span><span class="nf">.contains</span><span class="p">(</span><span class="nn">LeaseAttributes</span><span class="p">::</span><span class="n">READ</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">ResponseCode</span><span class="p">::</span><span class="n">BadArg</span><span class="p">);</span>
                    <span class="p">}</span>

                    <span class="c1">// Set our state machine, including saving the</span>
                    <span class="c1">// caller.</span>
                    <span class="o">*</span><span class="n">dataref</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">MyData</span> <span class="p">{</span>
                        <span class="n">task</span><span class="p">:</span> <span class="n">caller</span><span class="p">,</span>
                        <span class="n">pos</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                        <span class="n">len</span><span class="p">:</span> <span class="n">info</span><span class="py">.len</span>
                    <span class="p">});</span>

                    <span class="n">B</span><span class="py">.intstat</span><span class="nf">.write</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="n">w</span><span class="py">.interrupt_en</span><span class="nf">.set</span><span class="p">());</span>
                    <span class="nf">Ok</span><span class="p">(())</span>
                <span class="p">}</span>
                <span class="nn">Op</span><span class="p">::</span><span class="n">Read</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="c1">// Looks almost identical to Write except</span>
                    <span class="c1">// We check the borrow against</span>
                    <span class="c1">// LeaseAttributes::WRITE</span>
                <span class="p">}</span>
            <span class="p">},</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_driver_api_crates">9.3.3. Driver API crates</h4>
<div class="paragraph">
<p>A server called <code>drv-xyz-encoder-server</code> should, by convention, provide clients
with a corresponding API wrapper crate called <code>drv-xyz-encoder-api</code>. This will
normally use the <code>userlib::hl</code> module under the hood to generate IPC.</p>
</div>
<div class="paragraph">
<p>An example API might look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">enum</span> <span class="n">Op</span> <span class="p">{</span>
    <span class="n">Write</span><span class="p">,</span>
    <span class="n">Read</span><span class="p">,</span>
    <span class="n">Reset</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">Peripheral</span> <span class="p">{</span>
    <span class="n">Alpha</span><span class="p">,</span>
    <span class="n">Bravo</span><span class="p">,</span>
    <span class="n">Charlie</span><span class="p">,</span>
    <span class="n">Delta</span><span class="p">,</span>
    <span class="n">Echo</span><span class="p">,</span>
    <span class="n">Foxtrot</span>
<span class="p">}</span>

<span class="c1">// This serves as a handle for the server.</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="nf">Data</span><span class="p">(</span><span class="n">TaskId</span><span class="p">);</span>

<span class="k">impl</span> <span class="n">Data</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">peripheral</span><span class="p">:</span> <span class="n">Peripheral</span><span class="p">,</span> <span class="n">entry</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="nf">WriteData</span><span class="p">(</span><span class="n">Peripheral</span><span class="p">,</span> <span class="nb">u32</span><span class="p">);</span>

        <span class="k">impl</span> <span class="nn">hl</span><span class="p">::</span><span class="n">Call</span> <span class="k">for</span> <span class="n">WriteData</span> <span class="p">{</span>
            <span class="k">const</span> <span class="n">OP</span><span class="p">:</span> <span class="nb">u16</span> <span class="o">=</span> <span class="nn">Op</span><span class="p">::</span><span class="n">Write</span> <span class="k">as</span> <span class="nb">u16</span><span class="p">;</span>
            <span class="c1">// We don't expect a meaningful response.</span>
            <span class="k">type</span> <span class="n">Response</span> <span class="o">=</span> <span class="p">();</span>
            <span class="c1">// Error is just an int</span>
            <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="nb">u32</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nn">hl</span><span class="p">::</span><span class="nf">send</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="p">,</span> <span class="o">&amp;</span><span class="nf">WriteData</span><span class="p">(</span><span class="n">peripheral</span><span class="p">,</span> <span class="n">entry</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="caboose">9.4. The caboose</h3>
<div class="paragraph">
<p>At times, users may wish for a Hubris archive to contain information with the
following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Decided <strong>after</strong> the image is built</p>
</li>
<li>
<p>Readable in a wide variety of situations:</p>
<div class="ulist">
<ul>
<li>
<p>A live system with well-known APIs to request it (e.g. over the network)</p>
</li>
<li>
<p>A Hubris build archive</p>
</li>
<li>
<p>A binary file, given the original build archive</p>
</li>
<li>
<p>A binary file, <strong>without</strong> the original build archive</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that a live system with a debugger attached is morally equivalent to "a
binary file", because we can read arbitrary memory.</p>
</div>
<div class="paragraph">
<p>The motivating example of this data is a component-level version: after building
an image, a separate release engineering process wants to assign it a
user-facing version (e.g. <code>1.2.3</code>) and store that information <em>somewhere</em> in the
image.</p>
</div>
<div class="paragraph">
<p>The "caboose" is a region of flash allocated for this purpose. It is declared
with a <code>[caboose]</code> section in an <code>app.toml</code>, e.g.</p>
</div>
<div id="caboose-words" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="toml"><span class="k">[</span><span class="n">caboose</span><span class="k">]</span>
<span class="n">region</span> <span class="o">=</span><span class="w"> </span><span class="s">"flash"</span>
<span class="n">size</span> <span class="o">=</span><span class="w"> </span><span class="mi">128</span>
<span class="n">tasks</span> <span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s">"caboose_reader"</span><span class="p">]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If this section is present in an <code>app.toml</code>, the build system reserves an
appropriately-aligned section of memory for the caboose.  The caboose is located
at the <strong>end</strong> of flash (after the final task), and is aligned so that it can be
mapped as an MPU region. Only tasks declared in <code>caboose.tasks</code> are allowed to
read data from the caboose region of flash.  If other tasks attempt to read from
this memory region, they will experience the typical memory fault.</p>
</div>
<div class="paragraph">
<p>The Hubris build system will populate the caboose with start and end words
(32-bit words) words, and a sequence of
<a href="https://github.com/oxidecomputer/tlvc">TLV-C</a> key-value pairs containing image
metadata:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 66.6668%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Value</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Start</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>u32</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>abi::CABOOSE_MAGIC</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GITC</code> tag</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TLV-C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The current Git commit hash with an optional trailing "-dirty" if the
repository contains uncommitted changes.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BORD</code> tag</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TLV-C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name of the target board, as specified in the image&#8217;s TOML config.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NAME</code> tag</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TLV-C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name of the image, as specified in the image&#8217;s TOML config.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>VERS</code> tag</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TLV-C <em>(optional)</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The value of the <code>HUBRIS_CABOOSE_VERS</code> environment variable at build time,
if it was set.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>u8</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>(filled with <code>0xFF</code>)</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>End</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>u32</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Caboose size (little-endian <code>u32</code>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The caboose&#8217;s length is included in the <code>total_image_len</code> field of
<code>abi::ImageHeader</code>.  Because the caboose is located at the end of flash, its
presence and size can be determined as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Read total image length from the <code>ImageHeader</code></p>
<div class="ulist">
<ul>
<li>
<p>At runtime, this is a variable that can be read by the kernel</p>
</li>
<li>
<p>At rest, the image header is at a known location (depending on
microcontroller) and includes a distinctive magic number
(<code>abi::HEADER_MAGIC</code>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Read the final word of the image, which may be the caboose length</p>
</li>
<li>
<p>Subtract this value from total image length to get the (presumptive) caboose
start</p>
<div class="ulist">
<ul>
<li>
<p>If this subtraction underflows or exceeds the bounds of flash, the caboose is
not present.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Read the first word of the (presumptive) caboose</p>
<div class="ulist">
<ul>
<li>
<p>If this word is not <code>abi::CABOOSE_MAGIC</code>, then the caboose is not present</p>
</li>
<li>
<p>Otherwise, the caboose position and length is now known</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that this procedure works both at runtime and from a binary file, with or
without an associated Hubris archive.</p>
</div>
<div class="paragraph">
<p>To reduce runtime overhead, the caboose position may also be baked into an
individual task image at build time. This is implemented in the
<code>drv-caboose-pos</code> crate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">let</span> <span class="n">caboose</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">'static</span> <span class="p">[</span><span class="nb">u8</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">drv_caboose_pos</span><span class="p">::</span><span class="n">CABOOSE_POS</span><span class="nf">.as_slice</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>(This functionality requires cooperation with the <code>xtask</code> build system, as we
can&#8217;t know the caboose position until all tasks have been built)</p>
</div>
<div class="paragraph">
<p>Besides the start and end words and the default metadata described above, the
Hubris build system is agnostic to any further contents of the caboose. A
separate release engineering process may decide to store any arbitrary data in
the remaining space. The
<a href="https://github.com/oxidecomputer/hubtools"><code>hubtools</code> repository</a> includes a
library and CLI for modifying the caboose of a Hubris archive.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_references">References</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="shap03vuln"></a>[shap03vuln] Jonathan Shapiro.
<a href="http://srl.cs.jhu.edu/courses/600.439/shap03vulnerabilities.pdf">Vulnerabilities
in Synchronous IPC Designs</a>. 2003. <em>Short-ish and straightforward, Shap pokes
a bunch of holes in conventional IPC designs.</em></p>
</li>
<li>
<p><a id="herder08ipc"></a>[herder08ipc] Jorrit N. Herder et al.
<a href="https://www.cs.vu.nl/~herbertb/papers/minix3ipc_prdc08.pdf">Countering IPC
Threats In Multiserver Operating Systems: A Fundamental Requirement for
Dependability</a>. 2008. <em>This paper marked MINIX 3&#8217;s transition from a teaching
tool to a high-reliability research platform.</em></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. Or, that the task has been restarted by a debug tool or supervision policy, but those don&#8217;t make this point invalid for reasons we&#8217;ll discuss later.
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-10-28 18:43:33 UTC
</div>
</div>
</body>
</html>