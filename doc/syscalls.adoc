:toc:

= Hubris Syscalls

Syscalls provide ways for tasks to invoke kernel code. Hubris has a very small
set of syscalls, because syscalls -- unlike IPC -- have to be implemented in the
kernel and are hard to proxy, so they form an ongoing ABI commitment.

In general, the following sorts of things are syscalls (exhaustive):

- IPC primitives
  - Send, Receive, Reply
  - Planned extensions for asynchronous/nonblocking send
  - Lease/Borrow support
- Notification primitives
  - Updating the current task's notification mask

And the following sorts of things are not (not exhaustive):

- Task management
  - Starting or restarting tasks
  - Getting task priorities
- Timer management
- Interrupt control
- etc.

In general, syscalls should represent *operations that every task should have
access to,* while anything privileged or sensitive should be done through IPC.

This doesn't mean all these things need to be done outside the kernel, though.
We have an escape hatch, in the form of messages to the virtual "kernel task."

== Syscall ABI

Syscalls are invoked using the architecture's supervisor-call instruction or
equivalent.

We'll describe syscalls in an architecture-independent manner below by referring
to abstract argument and return slots instead of register names. Syscalls have
seven argument slots and eight return slots.

=== ARMv7-M / ARMv8-M

Syscalls are invoked using the `SVC` instruction. The 8-bit immediate in the
instruction is ignored, because reading it from user text is potentially
sketchy.

Syscalls provide for up to 7 arguments and 8 return values in registers.
Syscalls never use arguments from the stack, to make it easier to reason about
possible memory management faults during syscall entry (i.e. now there aren't
any).

Arguments to syscalls are passed in `r4` through `r10`, with the syscall index
in `r11`.

Return values from syscalls are returned in `r4` through `r11`.

NOTE: You're probably wondering why we're using weird registers instead of the
standard calling convention, which would pass things in `r0` through `r3`. It
comes back to the point above about stack accesses. The ARMv-7M hardware stores
`r0` through `r3` _on the user stack_ on entry to a syscall, and we don't want
to have to read it back from there. `r4` through `r11`, on the other hand, are
treated as callee-save, and our syscall entry sequence saves them into the TCB,
where we can refer to them as needed.

=== RISC-V

Syscalls are invoked using the `ECALL` instruction. The rest is TBD.

== Syscalls

=== `SEND` (0)

Sends a message.

The error-free path:

- Identifies the desired recipient.
- Transfers a message (0+ bytes) from an outgoing slice in your task's memory,
  into an incoming slice in the recipient's memory.
- Waits until the recipient calls `REPLY`.
- During this time, allows the recipient to access your task's memory, subject
  to the rules laid out in the lease table.
- Once `REPLY` happens, transfers the reply from the recipient's memory into the
  reply buffer slice in your task's memory.
- Resumes your task.

==== Arguments

* 0: packed target and operation.
** Bits 31:16: target task ID (split into index and generation per the constants
   in the `abi` crate).
** Bits 15:0: operation code (application defined).
* 1: Base address of outgoing message.
* 2: Length of outgoing message, in bytes.
* 3: Base address of buffer where a reply should be deposited.
* 4: Size of reply buffer, in bytes.
* 5: Base address of lease table.
* 6: Number of leases in lease table.

==== Lease table layout

Each lease is 12 bytes in size and must be 4-byte aligned. A lease is equivalent
to the following Rust struct:

[source, rust]
---------------------------------------------------------------------
#[repr(C)]
struct Lease {
    attributes: u32,
    base_address: usize,
    length: usize,
}

const ATT_READ: u32 = 1 << 0;
const ATT_WRITE: u32 = 1 << 1;
---------------------------------------------------------------------

- `attributes` can specify that a lease can be read from, written to, or both.
  Any use of undefined attribute bits will cause a fault.
- `base_address` is a byte-aligned address. If this points to memory your task
  can't access, it will cause a fault.
- `length` is the length of the leased memory region in bytes.

==== Return values

- 0: response code (application defined with caveat below).
- 1: length of reply deposited into reply buffer.

==== Faults

Most things that can go wrong with `SEND` are programming errors, and will cause
your task to be immediately faulted instead of returning a code.

|===
| Condition | Fault taken

| Recipient forbidden by your task's (static) IPC mask.
| `BadInteraction`

| Recipient task index greater than the (static) number of tasks in the entire
  system.
| `TaskOutOfRange`

| Any slice invalid (e.g. it would wrap the end of the address space).
| `InvalidSlice`

| Lease table slice misaligned.
| `InvalidSlice`

| Outgoing slice or lease table are memory you can't actually read.
| `MemoryAccess`

| Reply buffer slice is memory you can't actually write.
| `MemoryAccess`

|===

==== Notes

Target and operation are packed into a single word because we're out of useful
registers on ARMv7-M. This currently limits operation codes to 16 bits. We might
revisit this later.

For all slices (outgoing message, reply buffer, lease table), if the count is
zero, the base address won't be dereferenced and can be illegal. In particular,
it's okay to pass address 0 for empty slices.

If the slices are *not* zero length, however, the kernel will check them against
your task's memory map, and your task will be faulted if anything is amiss.

Slices are accessed by the kernel *only* while your task is blocked in `SEND`,
so passing a slice to the kernel here can be done safely (in the Rust sense).
The reply buffer slice must be an `&mut`, but the others can be `&`.

The lease table slice must be 4-byte aligned. The others can be arbitrarily
aligned.

Response codes are application defined except for one subtlety, which is that a
message sent to a dead task (one where the generation doesn't match) will always
reply with the response code `!0` (i.e. all bits set). All other values are
available for the application. It is possible to fake a dead task by
deliberately replying with a response code of `!0`, because it didn't seem
useful to filter it out.

=== `RECV` (1)

Receives a pending message.

The error-free path:

- Blocks until some number of tasks are ready to send to your task.
- Picks the highest priority one.
- Transfers its message into memory you've designated.
- Keeps the sending task blocked.
- Returns information describing the message to your task.

If the provided notification mask is not zero, the receive operation may be
interrupted by a _notification message_ from the kernel instead (if any of the
given notifications have been posted). Notification messages can be
distinguished by having the illegal sender `0xFFFF`.

==== Closed vs Open RECV

One argument to RECV determines whether to accept messages from _any_ sender, or
to only accept messages from _one._ Accepting messages from any sender is called
an "open" receive, while only listening for one sender is "closed."

During an open receive, a task may receive messages sent by any other task, plus
any notifications enabled by the notification mask.

During a closed receive, a task will receive messages only from the chosen task.
The task will *not* receive notifications unless the chosen sender ID is the
kernel's task ID, `0xFFFF`.

==== Arguments

- 0: Address of a buffer where received messages should be written.
- 1: Number of bytes in that buffer.
- 2: Notification mask to apply during this receive.
- 3: Sender filter for open vs closed receive.
** Bit 31: 0=open, 1=closed
** Bits 30:16: reserved
** Bits 15:0: TaskId if closed, ignored if open.

==== Return values

- 0: always 0 for open receive; closed receive may also return `!0` to indicate
  that the chosen peer has died.
- 1: Task ID of the sender (generation in 15:12, ID in 11:0).
- 2: Operation code used by sender.
- 3: Length of message sent.
- 4: Number of leases provided with message.

==== Faults

Most things that can go wrong with `RECV` are programming errors, and will cause
your task to be immediately faulted instead of returning a code.

|===
| Condition | Fault taken

| Receive buffer slice invalid (i.e. would wrap the end of the address space).
| `InvalidSlice`

| Receive buffer slice is memory you can't actually write.
| `MemoryAccess`

|===

==== Notes

It's legal to specify a zero-length receive buffer. In this case, the base
address is ignored. This can be useful if you only need to distinguish between
messages by their operation codes.

If the sender sent a message _longer_ than your receive buffer, you will get the
_prefix_ of the message, and the returned response length will give the _actual_
length. This means you should check the response length against your buffer
length to detect truncation.

Leases received with the message are referenced with the combination (TaskID,
lease number). Lease numbers range between 0 and one less than the received
lease count, as you'd expect. Leases are only valid until the sending task
unblocks.

The notification mask is provided anew with each receive because the `RECV`
callsite has a clear idea of which notifications it can handle. Plus, it saves a
syscall during the common pattern of updating the mask and then receiving.

`RECV` is called `RECV` because Cliff can't spell "recieve" reliably.

=== `REPLY` (2)

Replies to a received message.

If all goes well, this copies a slice of data from your task's memory into the
caller's memory and resumes it.

==== Arguments

- 0: Task ID of sender we're replying to.
- 1: Response code to deliver.
- 2: Base address of reply message.
- 3: Number of bytes in reply message.

==== Return values

`REPLY` doesn't return anything, but should be treated as clobbering return
registers 0 and 1 for future compatibility.

==== Faults

There is only one way to break `REPLY`, and that's with a bogus slice.

|===
| Condition | Fault taken

| Outgoing buffer slice invalid (i.e. would wrap the end of the address space).
| `InvalidSlice`

| Outgoing buffer slice is memory you can't actually read.
| `MemoryAccess`

| Reply message is longer than recipient requested.
| `ReplyTooLarge`

|===

==== Notes

It might strike you as odd that `REPLY` doesn't return any status. This is a
subtle decision, and has to do with what servers will do if their clients
"defect" or crash before reply (generally: nothing).

Reply messages can be zero-length, in which case the base address of the slice
is ignored. Often, the response code is enough.

`RECV` delivers the size of the caller's response buffer, so your task has
sufficient information to not overflow it. This is why doing so is a fault: it's
a programming error.

=== `SET_TIMER` (3)

Configures your task's timer.

==== Arguments

- 0: Enable (1) or disable (0) flag.
- 1: Low 32 bits of deadline.
- 2: High 32 bits of deadline.
- 3: Notification bitmask to post when timer expires.

==== Return values

None. All registers preserved.

==== Faults

None.

==== Notes

The notification bitmask will be delivered into your task's notification set
when the kernel time becomes equal to or greater than the given deadline, if the
timer is enabled. Configuring the timer with an enabled deadline that is already
in the past delivers the notification immediately (though you won't notice until
you `RECV`).

The time unit for deadlines is not currently specified -- it's currently an
abstract "kernel ticks" unit. This will be fixed.

=== `GET_TIMER` (9)

Reads the contents of the task's timer: both the current time, and any
configured deadline.

==== Arguments

None.

==== Return values

- 0: low 32 bits of kernel timestamp.
- 1: high 32 bits of kernel timestamp.
- 2: 0=no deadline set, 1=deadline set.
- 3: low 32 bits of deadline, if set.
- 4: high 32 bits of deadline, if set.
- 5: notifications to post when deadline reached.

==== Faults

None.

==== Notes

The timestamp is defined as being CPU-wide, consistent for all tasks, so the
result of this syscall can be meaningfully sent to other tasks on the same CPU.
(Behavior in multicore situations is not yet defined.)

The time unit is not currently specified -- it's currently an abstract "kernel
ticks" unit. This will be fixed.
