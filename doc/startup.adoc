= Startup

This document describes how Hubris takes a CPU from reset to running your
application. It is mostly architecture-neutral; any architecture-specific bits
will be called out.

== From reset to Rust

At reset, the processor runs a designated chunk of code, the *reset handler.*
Hubris's reset handler is responsible for making the world safe for Rust code.
This means:

- Setting up a stack pointer, if the hardware doesn't do that for us;

- Enabling any processor features or memory devices required to run the kernel
  -- for example, if the device has an FPU, we need it turned on so we can
  configure it even though the kernel itself may not use floating point;

- Ensuring that all initialized variables get initialized;

- Jumping to `main`.

On ARMv6-M, ARMv7-M, and ARMv8-M this sequence is handled by the `cortex_m_rt`
crate, which in turn uses the `r0` crate to set up Rust variables.

== `main`: bring your own

Currently, Hubris expects the application packager (i.e. you) to provide a
`main` routine in the crate that builds the kernel. This gives you an
opportunity to do any setup that isn't handled by the runtime startup, but needs
to happen before the kernel boots.

`main` should do those things, and then call `start_kernel`.

This same file is where you might declare interrupt service routines for any
SoC-specific interrupts that you wish to handle outside Hubris's standard
mechanism -- for cases where an interrupt is so latency-sensitive that you need
to handle it with a privileged ISR, despite the safety implications. Hubris's
internal ISR symbols are weak, so, declaring an ISR in this file overrides them.

== Starting the kernel

The kernel expects to be packaged in Flash with a table describing the tasks.
This table is defined in `kconfig.rs`, which is generated at compile time
by the kernel's `build.rs` and included at the bottom of
`sys/kern/src/startup.rs`.

The table consists of the following (all the types named here are defined in
the `abi` crate):

- An `App` header record describing the overall shape of things to come.
- One or more region descriptor (`RegionDesc`) records, carving up address
  space into regions with attributes.
- One or more task descriptor (`TaskDesc`) records describing tasks.

TIP: Region descriptors can technically be shared among tasks -- task
descriptors specify the regions they can access by _index_. Task descriptors
contain the initial program counter and stack pointer values for the task,
which will be loaded into those registers when the task first runs (or is
restarted). Hubris will check that those pointers fall within some memory
region, but other than that, the layout of your task memory regions and their
roles is totally up to you. This means you _could_ create an application with
tasks that share a Flash code region, for instance, though, think carefully
before doing so.

`start_kernel` reads the `App` header and the task and region descriptors,
validates their integrity, and initializes bookkeeping information for each
task described in the task table. This data is allocated in `static mut` arrays
`HUBRIS_TASK_TABLE_SPACE` and `HUBRIS_REGION_TABLE_SPACE`, which are declared
in the autogenerated `kconfig.rs`. The few kernel global variables are *not*
placed here; it's only used for stuff that is sized based on information found
in the `app.toml` configuration.

Any extra RAM allocated to the kernel, but not used, is lost.

== Starting the first task(s)

One of the fields in the task descriptor contains a `START_AT_BOOT` flag. Any
task with this flag set will be initialized in `Runnable` state; all others are
initialized in `Stopped` state. (The `START_AT_BOOT` flag in the descriptor
corresponds to the `start = true` field in the `app.toml`.)

As its last act during startup, the kernel scans the tasks looking for the
*highest priority* task marked `START_AT_BOOT`. It then switches into that task,
and your application is running.

If the task descriptor table contains *zero* tasks marked `START_AT_BOOT`, this
represents an application configuration error, and the kernel will panic.

=== Example

Consider the following device which does not exist:

```
High address    +-------------------------------------+<----+ Peripherals end
                |     Device3 Registers (RW, device)  |
                |                                     |
                |                                     |
 0x40002000 +-> +-------------------------------------+
                |     Device2 Registers (RW, device)  |
                |                                     |
                |                                     |
 0x40001000 +-> +-------------------------------------+
                |     Device1 Registers (RW, device)  |
                |                                     |
 0x40000000 +-> +--------------------------------------<----+ Peripherals Start
                |     Empty address space             |
                +--------------------------------------<----+ RAM end
                |     Task2 .data (RW)                |
                |                                     |
    0x21000 +-> +-------------------------------------+
                |     Task2 stack (RW)                |
                |                                     |
    0x20000 +-> +-------------------------------------+
                |     Task1 .data (RW)                |
                |                                     |
    0x12000 +-> +-------------------------------------+
                |     Task1 Stack (RW)                |
                |                                     |
    0x11000 +-> +--------------------------------------<---+ hubris_kernel_ram_end
                |     Kernel RAM                      |
                |                                     |
    0x10000 +-> +--------------------------------------<----+ RAM start/hubris_kernel_ram_start
                |     Empty address space             |
     0x3000 +-> +--------------------------------------<----+ Flash end
                |     Task2 .rodata (RO)              |
                |                                     |
                +-------------------------------------+
                |     Task2 .text (RO)                |
                |                                     |
     0x2000 +-> +-------------------------------------+
                |     Task1 .rodata (RO)              |
                |                                     |
                +-------------------------------------+
                |     Task1 .text (RO)                |
                |                                     |
     0x1000 +-> +-------------------------------------+
                |     Vectors                         |
 Low address    +-------------------------------------v<-----+Flash start


```

Suppose that Task1 needs access to Device1 and Device3 and Task2 needs
access to Device2 and Device3. The descriptors would look like:

```
App {
	magic: kernel::app::CURRENT_APP_MAGIC,
	region_count:
	task_count: 2,
	zeroed_expansion_space: [0; 16],
}
TaskDesc {
	entry_point: 0x1000
	flags: TaskFlags::START_AT_BOOT,
	initial_stack: 0x12000
	regions: [1, 2, 5, 7, 0, 0, 0, 0]
}
TaskDesc {
	entry_point: 0x2000
	flags: TaskFlags::START_AT_BOOT,
	initial_stack: 0x21000,
	regions: [3, 4, 6, 7, 0, 0, 0, 0]
}

# The empty region
RegionDesc {
	base: 0
	size: !0
	attributes: RegionAttributes::RW
	reserved_zero: 0
}

# Task 1 Read Only
RegionDesc {
	base: 0x1000
	size: 0x1000
	attributes: RegionAttributes::RO
	reserved_zero: 0
}
# Task 1 Read Write
RegionDesc  {
	base: 0x11000
	size: 0x2000
	attributes: RegionAttributes::RW
	reserved_zero: 0
}
# Task 2 Read Only
RegionDesc {
	base: 0x2000
	size: 0x1000
	attributes: RegionAttributes::RO
	reserved_zero: 0
}
# Task 2 Read Write
RegionDesc {
	base: 0x20040
	size: 0x40
	attributes: RegionAttributes::RW
	reserved_zero: 0
}
# Device 1
RegionDesc {
	base: 0x40000000
	size: 0x1000
	attributes: RegionAttributes::Device | RegionAttributes::RW
	reserved_zero: 0
}
# Device 2
RegionDesc  {
	base: 0x40001000
	size: 0x1000
	attributes: RegionAttributes::Device | RegionAttributes::RW
	reserved_zero: 0
}
# Device 3
RegionDesc  {
	base: 0x40002000
	size: 0x1000
	attributes: RegionAttributes::Device | RegionAttributes::RW
	reserved_zero: 0
}
```
