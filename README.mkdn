# Hubris

[![build](https://github.com/oxidecomputer/hubris/workflows/build/badge.svg)](https://github.com/oxidecomputer/hubris/actions?query=workflow%3Abuild)

Hubris is a microcontroller operating environment designed for deeply-embedded
systems with reliability requirements. Its design was initially proposed in
RFD41, but has evolved considerably since then.

# Learning

We have some documentation in disjointed files in the `doc/` directory.

# Developing

## Prereqs

You will need:

- The nightly toolchain. (It will *probably* automatically install when you try
  to build, but people have had issues.)

- `openocd` (mostly tested on 0.10)

- The appropriate Rust toolchain target installed: `rustup target add
  thumbv7em-none-eabihf`

- `itmdump`: `cargo install itm`

### Windows

If you're on Windows, you can get set up by doing this:

You can easily install `openocd` with [scoop](https://scoop.sh/):

```console
> scoop bucket add extras
> scoop install openocd
```

You'll probably need to install [this
driver](https://www.st.com/en/development-tools/stsw-link009.html).

If your terminal doesn't support serial connections, you'll want to also use
PuTTY; [this guide](https://pbxbook.com/voip/sputty.html) does a good job of
explaining how.

Finally, the instructions below invoke shell scripts. They're very small, and
so for now you can run the commands manually, yourself. We may improve this
in the future.

## Build and run

`cargo build` from the top level directory will not build anything, because a
single `cargo build` invocation can only do one architecture at a time.
Likewise, `cargo run` will not do anything either.

Here's how to build and run the firmware.

Connect an STM32F4 Discovery board, which is the currently supported
demonstrator platform.

Launch `openocd` in one terminal, *from this directory* so it finds its config
files:

```shell
$ openocd
```

From another terminal:

```shell
$ ./run.sh
```

If this works, you'll see `gdb` mumble some things about flashing, `openocd`
will scroll by some updates, and you will eventually be unceremoniously
deposited at a `(gdb)` prompt halted on the first instruction. Type `c` /
`continue` to run.

## Iterating

During development you'll probably want to build a single task, outside the
context of an image, to e.g. verify that it compiles. We've set things up so
that you can build a task to a default, placeholder memory map.

```shell
$ cd task-ping
$ cargo build
```

This magic happens in three parts:

1. Each task directory contains a `.cargo/config` file specifying an
   architecture (so you don't have to) and a linker script. This file is honored
   *only* when building inside the task's directory, because Cargo.
2. Our `build.rs` files that receive information from the `package` xtask will do
   reasonable defaulty things if that information is missing, e.g. when you
   build it manually.
3. By convention, we set a default feature `"standalone"` for standalone builds,
   and switch it off in the `app.toml` used by the `package` xtask. You can use this
   feature to conditionally compile stuff.

Note: most tasks pick up their `build.rs` behavior implicitly by depending on
`userlib`.

To create your own task, the easiest method is to copy `task-template` to a new
name and edit its `Cargo.toml`.
