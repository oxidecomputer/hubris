# Hubris

[![build](https://github.com/oxidecomputer/hubris/workflows/build/badge.svg)](https://github.com/oxidecomputer/hubris/actions?query=workflow%3Abuild)

Hubris is a microcontroller operating environment designed for deeply-embedded
systems with reliability requirements. Its design was initially proposed in
RFD41, but has evolved considerably since then.

# Learning

We have some documentation in disjointed files in the `doc/` directory. This
file gives quick-start information.

# Developing

We currently support Linux and Windows as first-tier platforms. The build
probably also works on Illumos and Mac; if anyone would like to step up to
maintain support and a continuous build for those architectures, we'd love the
help.

## Prereqs

You will need:

- The nightly toolchain. (It will *probably* automatically install when you try
  to build, but people have had issues.)

- `openocd` (mostly tested on 0.10)

- The appropriate Rust toolchain target installed:
  - `rustup target add thumbv7em-none-eabihf`
  - `rustup target add thumbv8m.main-none-eabihf`

- `itmdump`: `cargo install itm`

- `arm-none-eabi-objcopy` and `arm-none-eabi-gdb`.

### Windows

If you're on Windows, you can get set up by doing this:

You can easily install `openocd` with [scoop](https://scoop.sh/):

```console
> scoop bucket add extras
> scoop install openocd
```

You'll probably need to install [this
driver](https://www.st.com/en/development-tools/stsw-link009.html).

If your terminal doesn't support serial connections, you'll want to also use
PuTTY; [this guide](https://pbxbook.com/voip/sputty.html) does a good job of
explaining how.

Finally, the instructions below invoke shell scripts. They're very small, and
so for now you can run the commands manually, yourself. We may improve this
in the future.

## Build

**We do not use `cargo build` or `cargo run` directly because they are too
inflexible for our purposes.** We have a complex multi-architecture build, which
is a bit beyond them.

Instead, the repo includes a Cargo extension called `xtask` that namespaces our
custom build commands.

- `cargo xtask dist TOMLFILE` builds a distribution image for the
  application described by the TOML file.
  - `cargo xtask dist demo/app.toml` - stm32f4-discovery
  - `cargo xtask dist lpc55/app.toml` - lpcxpresso55s69
  - `cargo xtask dist demo-stm32h7/app-h743.toml` - nucleo-ih743zi2
  - `cargo xtask dist demo-stm32h7/app-h7b3.toml` - stm32h7b3i-dk
- `cargo xtask build` from within a task or kernel directory builds that one
  component in isolation. **The result won't actually run,** because it's
  missing important system context, but this provides a cheaper way to do
  incremental builds during development. See the `Iterating` section below.

## Run

Details depend on your target board. Here are some common evaluation boards we
support.

### STM32F4 Discovery board

Connect board via USB.

From one terminal, `cd` into the root of this repository and run `openocd`.
(This causes `openocd` to pick up the `openocd.cfg` at the root.)

From another terminal:

```shell
$ cargo xtask gdb demo/app.toml openocd.gdb
```

If this works, you'll see `gdb` mumble some things about flashing, `openocd`
will scroll by some updates, and you will eventually be unceremoniously
deposited at a `(gdb)` prompt halted on the first instruction. Type `c` /
`continue` to run.

### LPCXpresso55S69 board

TODO: we need instructions for this, as it does not use openocd

### ST Nucleo-H743ZI2 board

- Terminal 1: `cd demo-stm32h7; openocd`
- Terminal 2: `cargo xtask gdb demo-stm32h7/app-h743.toml openocd.gdb`

### ST STM32H7B3I-DK board

- Terminal 1: `cd demo-stm32h7; openocd`
- Terminal 2: `cargo xtask gdb demo-stm32h7/app-h7b3.toml openocd.gdb`

## Adding a task

To create your own task, the easiest method is:

- Copy `task-template` to a new name.
- Edit its `Cargo.toml` with your name and a new package name.
- Add it to the list of workspace members in the root `Cargo.toml`.

You can now run `cargo xtask build` in the task's directory to run a standalone
build. (See below for details.)

To actually test the task, you need to add it to a system image by editing an
`app.toml` file. A typical entry for a small task that uses no memory-mapped
peripherals would read

```toml
[tasks.name_for_task_in_this_image]
path = "../my-task-directory"
name = "my-task-target-name"
priority = 1
requires = {flash = 1024, ram = 1024}
start = true
```

## Iterating

Because a full image build can take 10 seconds or more, depending on what you've
changed, when you're iterating on a task or kernel you'll probably want to build
it *outside* the context of an image. We have a thing called a "standalone
build" for this.

For instance, to run a standalone build of `task-ping`, run:

```shell
$ cd task-ping
$ cargo xtask build
```

This magic happens in three parts:

1. Packages that support standalone build have a `package.metadata.build.target`
   key giving the default target architecture for standalone builds.
2. Our `build.rs` files that receive information from the `dist` xtask will do
   reasonable defaulty things if that information is missing, e.g. in this case.
3. By convention, we set a default feature `"standalone"` for standalone builds,
   and switch it off in the `app.toml` used by the `package` xtask. You can use this
   feature to conditionally compile stuff.

Note: most tasks pick up their `build.rs` behavior implicitly by depending on
`userlib`. You generally do not need a `build.rs` in your task unless you need
to detect compiler/architecture features or depend on board rev.

