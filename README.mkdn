# Hubris

[![build](https://github.com/oxidecomputer/hubris/workflows/build/badge.svg)](https://github.com/oxidecomputer/hubris/actions?query=workflow%3Abuild)

Hubris is a microcontroller operating environment designed for deeply-embedded
systems with reliability requirements. Its design was initially proposed in
RFD41, but has evolved considerably since then.

# Learning

We have some documentation in disjointed files in the `doc/` directory. This
file gives quick-start information.

# Developing

We currently support Linux and Windows as first-tier platforms. The build
probably also works on Illumos and Mac; if anyone would like to step up to
maintain support and a continuous build for those architectures, we'd love the
help.

## Prereqs

You will need:

- The nightly toolchain. (It will *probably* automatically install when you try
  to build, but people have had issues.)

- `openocd` (mostly tested on 0.10)

- The appropriate Rust toolchain target installed:
  - `rustup target add thumbv7em-none-eabihf`
  - `rustup target add thumbv8m.main-none-eabihf`

- `itmdump`: `cargo install itm`

- `arm-none-eabi-objcopy` and `arm-none-eabi-gdb`.

### Windows

If you're on Windows, you can get set up by doing this:

You can easily install `openocd` with [scoop](https://scoop.sh/):

```console
> scoop bucket add extras
> scoop install openocd
```

You'll probably need to install [this
driver](https://www.st.com/en/development-tools/stsw-link009.html).

If your terminal doesn't support serial connections, you'll want to also use
PuTTY; [this guide](https://pbxbook.com/voip/sputty.html) does a good job of
explaining how.

Finally, the instructions below invoke shell scripts. They're very small, and
so for now you can run the commands manually, yourself. We may improve this
in the future.

## Build

**We do not use `cargo build` or `cargo run` directly because they are too
inflexible for our purposes.** We have a complex multi-architecture build, which
is a bit beyond them.

Instead, the repo includes a Cargo extension called `xtask` that namespaces our
custom build commands.

- `cargo xtask dist TOMLFILE` builds a distribution image for the
  application described by the TOML file.
  - `cargo xtask dist demo/app.toml` - stm32f4-discovery
  - `cargo xtask dist lpc55/app.toml` - lpcxpresso55s69
  - `cargo xtask dist demo-stm32h7/app-h743.toml` - nucleo-ih743zi2
  - `cargo xtask dist demo-stm32h7/app-h7b3.toml` - stm32h7b3i-dk
- `cargo xtask build` from within a task or kernel directory builds that one
  component in isolation. **The result won't actually run,** because it's
  missing important system context, but this provides a cheaper way to do
  incremental builds during development. See the `Iterating` section below.

## Run

Details depend on your target board. Here are some common evaluation boards we
support.

### STM32F4 Discovery board

Connect board via USB.

From one terminal, `cd` into the root of this repository and run `openocd`.
(This causes `openocd` to pick up the `openocd.cfg` at the root.)

From another terminal:

```shell
$ cargo xtask gdb demo/app.toml openocd.gdb
```

If this works, you'll see `gdb` mumble some things about flashing, `openocd`
will scroll by some updates, and you will eventually be unceremoniously
deposited at a `(gdb)` prompt halted on the first instruction. Type `c` /
`continue` to run.

### LPCXpresso55S69 board

The LPCXpresso55S69 is somewhat of a mess because  
the built-on on-chip debugger, LPC-Link2, <a href="https://community.nxp.com/t5/LPC-Microcontrollers/SWO-SWV-on-LPC-Link2-with-CMSIS-DAP/m-p/1079442">does not correctly support SWO/SWV</a>.

To use the LPCXpresso55S69, you will need <a href="https://github.com/mbedmicro/pyOCD">, version 0.27.0 or later.
You can verify that you need to upgrade the firmware by running `pyocd list`:

```shell
$ pyocd list
  #   Probe                                           Unique ID
-----------------------------------------------------------------
  0   NXP Semiconductors LPC-LINK2 CMSIS-DAP V5.361   JSAQCQIQ
```

It's also possible that you have the Segger J-Link firmware -- firmware
that will make its odious presence known by prompting for you to accept license
terms (!!) whenever running `pyocd list`:

```shell
$ pyocd list
  #   Probe                                                       Unique ID
-----------------------------------------------------------------------------
  0   Segger J-Link LPCXpresso V2 compiled Apr  4 2019 16:54:03   726424936
```

In either of these cases you must -- as a one-time step -- install new
firmware on the LPC-Link2.  This is a build of the (open source) 
<a href="https://github.com/oxidecomputer/DAPLink">DAPLink</a> (which
we affectionally call "RickLink" after
the engineer who managed to get it all built -- no small feat!).

There are two files that you will need, both contained in the Hubris repository:

- <a href="./support/lpc4322_bl_crc.bin">lpc4322_bl_crc.bin</a>
- <a
  href="./support/lpc4322_lpc55s69xpresso_if_rla_swo_hacks.bin">lpc4322_lpc55s69xpresso_if_rla_swo_hacks.bin</a>

You will additionally need the <a
href="https://www.nxp.com/design/microcontrollers-developer-resources/lpc-microcontroller-utilities/lpcscrypt-v2-1-1:LPCSCRYPT">LPCScrypt program</a> from NXP.

1. Install the DFU jumper. This can be found next to the SWD header on the
left side of the board; it is labelled "DFU".

2. Run `scripts/boot_lpcscrypt` from the installed LPCScrypt software:

```shell
$ /usr/local/lpcscrypt/scripts/boot_lpcscrypt 
Looking for DFU devices with VID 1fc9 PID 000c ...
dfu-util -d 1fc9:000c -c 1 -i 0 -t 2048 -R  -D /usr/local/lpcscrypt/scripts/../bin/LPCScrypt_228.bin.hdr
Booted LPCScrypt target (1fc9:000c) with /usr/local/lpcscrypt/scripts/../bin/LPCScrypt_228.bin.hdr
$
```

3. Run `lpcscrypt clockslow`:

```shell
$ /usr/local/lpcscrypt/bin/lpcscrypt clockslow
$
```

4. Run `lpcscrypt program +c <path-to-lpc4322_bl_crc.bin> BankA`:

```shell
$ /usr/local/lpcscrypt/bin/lpcscrypt program +c ~/hubris/support/lpc4322_bl_crc.bin BankA
..
Programmed 57344 bytes to 0x1a000000 in 0.827s (67.717KB/sec)
$
```

5. Assuming it is successful, remove the DFU jumper and disconnect/reconnect USB

6. There should now be a USB mass storage device named `MAINTENANCE`

```shell
# fdisk -l
Disk /dev/nvme0n1: 477 GiB, 512110190592 bytes, 1000215216 sectors
Disk model: Micron 2200S NVMe 512GB
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: A8653F99-39AB-4F67-A9C9-524A2864856E

Device             Start        End   Sectors   Size Type
/dev/nvme0n1p1      2048    1050623   1048576   512M EFI System
/dev/nvme0n1p2   1050624  967393279 966342656 460.8G Linux filesystem
/dev/nvme0n1p3 967393280 1000214527  32821248  15.7G Linux swap


Disk /dev/sda: 64.1 MiB, 67174400 bytes, 131200 sectors
Disk model: VFS
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x00000000
# mount /dev/sda /mnt
# ls /mnt
DETAILS.TXT  PRODINFO.HTM
# cat /mnt/DETAILS.TXT
# DAPLink Firmware - see https://mbed.com/daplink
Unique ID: 02360b000d96e4fc00000000000000000000000097969905
HIC ID: 97969905
Auto Reset: 1
Automation allowed: 1
Overflow detection: 1
Daplink Mode: Interface
Interface Version: 0254
Bootloader Version: 0254
Git SHA: f499eb6ec4a847a2b78831fe1acc856fd8eb2f28
Local Mods: 1
USB Interfaces: MSD, CDC, HID, WebUSB
Bootloader CRC: 0x09974fb3
Interface CRC: 0x7174ab4c
Remount count: 0
URL: https://os.mbed.com/platforms/LPCXpresso55S69/
```

7. Copy `lpc4322_lpc55s69xpresso_if_rla_swo_hacks.bin` to the USB drive

```shell
$ sudo cp ~/hubris/support/lpc4322_lpc55s69xpresso_if_rla_swo_hacks.bin /mnt
$
```

8. Unmount (or otherwise sync) the USB drive:

```shell
# umount /mnt
#
```

9. Unplug and replug the USB cable.

Verify that you are on the new firmware by running `pyocd list`:

```shell
$ pyocd list
  #   Probe                        Unique ID                                         
-------------------------------------------------------------------------------------
  0   LPCXpresso55S69 [lpc55s69]   02360b000d96e4fc00000000000000000000000097969905  
```

Once RickLink is running:

- Terminal 1: `pyocd gdbserver -t lpc55s69`
- Terminal 2: `telnet localhost 4444`
- Terminal 3: `cargo xtask gdb lpc55/app.toml openocd.gdb`

### ST Nucleo-H743ZI2 board

- Terminal 1: `cd demo-stm32h7; openocd`
- Terminal 2: `cargo xtask gdb demo-stm32h7/app-h743.toml openocd.gdb`

### ST STM32H7B3I-DK board

- Terminal 1: `cd demo-stm32h7; openocd`
- Terminal 2: `cargo xtask gdb demo-stm32h7/app-h7b3.toml openocd.gdb`

## Adding a task

To create your own task, the easiest method is:

- Copy `task-template` to a new name.
- Edit its `Cargo.toml` with your name and a new package name.
- Add it to the list of workspace members in the root `Cargo.toml`.

You can now run `cargo xtask build` in the task's directory to run a standalone
build. (See below for details.)

To actually test the task, you need to add it to a system image by editing an
`app.toml` file. A typical entry for a small task that uses no memory-mapped
peripherals would read

```toml
[tasks.name_for_task_in_this_image]
path = "../my-task-directory"
name = "my-task-target-name"
priority = 1
requires = {flash = 1024, ram = 1024}
start = true
```

## Iterating

Because a full image build can take 10 seconds or more, depending on what you've
changed, when you're iterating on a task or kernel you'll probably want to build
it *outside* the context of an image. We have a thing called a "standalone
build" for this.

For instance, to run a standalone build of `task-ping`, run:

```shell
$ cd task-ping
$ cargo xtask build
```

This magic happens in three parts:

1. Packages that support standalone build have a `package.metadata.build.target`
   key giving the default target architecture for standalone builds.
2. Our `build.rs` files that receive information from the `dist` xtask will do
   reasonable defaulty things if that information is missing, e.g. in this case.
3. By convention, we set a default feature `"standalone"` for standalone builds,
   and switch it off in the `app.toml` used by the `package` xtask. You can use this
   feature to conditionally compile stuff.

Note: most tasks pick up their `build.rs` behavior implicitly by depending on
`userlib`. You generally do not need a `build.rs` in your task unless you need
to detect compiler/architecture features or depend on board rev.

